{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"base64.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/utils/base64.ts"],"sourcesContent":["/*\n * The `chars`, `lookup`, `encode`, and `decode` members of this file are\n * licensed under the following:\n *\n *     base64-arraybuffer\n *     https://github.com/niklasvh/base64-arraybuffer\n *\n *     Copyright (c) 2012 Niklas von Hertzen\n *     Licensed under the MIT license.\n *\n */\n\nconst chars =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n// Use a lookup table to find the index.\nconst lookup = new Uint8Array(256);\nfor (let i = 0; i < chars.length; i++) {\n  lookup[chars.charCodeAt(i)] = i;\n}\n\nexport const encodeToBase64 = (bytes: Uint8Array): string => {\n  let base64 = '';\n  const len = bytes.length;\n  for (let i = 0; i < len; i += 3) {\n    base64 += chars[bytes[i] >> 2];\n    base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n    base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n    base64 += chars[bytes[i + 2] & 63];\n  }\n\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + '=';\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + '==';\n  }\n\n  return base64;\n};\n\nexport const decodeFromBase64 = (base64: string): Uint8Array => {\n  let bufferLength = base64.length * 0.75;\n  const len = base64.length;\n  let i;\n  let p = 0;\n  let encoded1;\n  let encoded2;\n  let encoded3;\n  let encoded4;\n\n  if (base64[base64.length - 1] === '=') {\n    bufferLength--;\n    if (base64[base64.length - 2] === '=') {\n      bufferLength--;\n    }\n  }\n\n  const bytes = new Uint8Array(bufferLength);\n\n  for (i = 0; i < len; i += 4) {\n    encoded1 = lookup[base64.charCodeAt(i)];\n    encoded2 = lookup[base64.charCodeAt(i + 1)];\n    encoded3 = lookup[base64.charCodeAt(i + 2)];\n    encoded4 = lookup[base64.charCodeAt(i + 3)];\n\n    bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n    bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n    bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n  }\n\n  return bytes;\n};\n\n// This regex is designed to be as flexible as possible. It will parse certain\n// invalid data URIs.\nconst DATA_URI_PREFIX_REGEX = /^(data)?:?([\\w\\/\\+]+)?;?(charset=[\\w-]+|base64)?.*,/i;\n\n/**\n * If the `dataUri` input is a data URI, then the data URI prefix must not be\n * longer than 100 characters, or this function will fail to decode it.\n *\n * @param dataUri a base64 data URI or plain base64 string\n * @returns a Uint8Array containing the decoded input\n */\nexport const decodeFromBase64DataUri = (dataUri: string): Uint8Array => {\n  const trimmedUri = dataUri.trim();\n\n  const prefix = trimmedUri.substring(0, 100);\n  const res = prefix.match(DATA_URI_PREFIX_REGEX);\n\n  // Assume it's not a data URI - just a plain base64 string\n  if (!res) return decodeFromBase64(trimmedUri);\n\n  // Remove the data URI prefix and parse the remainder as a base64 string\n  const [fullMatch] = res;\n  const data = trimmedUri.substring(fullMatch.length);\n\n  return decodeFromBase64(data);\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 85, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"file":"strings.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/utils/strings.ts"],"sourcesContent":["export const toCharCode = (character: string) => character.charCodeAt(0);\n\nexport const toCodePoint = (character: string) => character.codePointAt(0);\n\nexport const toHexStringOfMinLength = (num: number, minLength: number) =>\n  padStart(num.toString(16), minLength, '0').toUpperCase();\n\nexport const toHexString = (num: number) => toHexStringOfMinLength(num, 2);\n\nexport const charFromCode = (code: number) => String.fromCharCode(code);\n\nexport const charFromHexCode = (hex: string) => charFromCode(parseInt(hex, 16));\n\nexport const padStart = (value: string, length: number, padChar: string) => {\n  let padding = '';\n  for (let idx = 0, len = length - value.length; idx < len; idx++) {\n    padding += padChar;\n  }\n  return padding + value;\n};\n\nexport const copyStringIntoBuffer = (\n  str: string,\n  buffer: Uint8Array,\n  offset: number,\n): number => {\n  const length = str.length;\n  for (let idx = 0; idx < length; idx++) {\n    buffer[offset++] = str.charCodeAt(idx);\n  }\n  return length;\n};\n\nexport const addRandomSuffix = (prefix: string, suffixLength = 4) =>\n  `${prefix}-${Math.floor(Math.random() * 10 ** suffixLength)}`;\n\nexport const escapeRegExp = (str: string) =>\n  str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\nexport const cleanText = (text: string) =>\n  text.replace(/\\t|\\u0085|\\u2028|\\u2029/g, '    ').replace(/[\\b\\v]/g, '');\n\nexport const escapedNewlineChars = ['\\\\n', '\\\\f', '\\\\r', '\\\\u000B'];\n\nexport const newlineChars = ['\\n', '\\f', '\\r', '\\u000B'];\n\nexport const isNewlineChar = (text: string) => /^[\\n\\f\\r\\u000B]$/.test(text);\n\nexport const lineSplit = (text: string) => text.split(/[\\n\\f\\r\\u000B]/);\n\nexport const mergeLines = (text: string) =>\n  text.replace(/[\\n\\f\\r\\u000B]/g, ' ');\n\n// JavaScript's String.charAt() method doesn work on strings containing UTF-16\n// characters (with high and low surrogate pairs), such as ðŸ’© (poo emoji). This\n// `charAtIndex()` function does.\n//\n// Credit: https://github.com/mathiasbynens/String.prototype.at/blob/master/at.js#L14-L48\nexport const charAtIndex = (text: string, index: number): [string, number] => {\n  // Get the first code unit and code unit value\n  const cuFirst = text.charCodeAt(index);\n  let cuSecond: number;\n  const nextIndex = index + 1;\n  let length = 1;\n  if (\n    // Check if it's the start of a surrogate pair.\n    cuFirst >= 0xd800 &&\n    cuFirst <= 0xdbff && // high surrogate\n    text.length > nextIndex // there is a next code unit\n  ) {\n    cuSecond = text.charCodeAt(nextIndex);\n    if (cuSecond >= 0xdc00 && cuSecond <= 0xdfff) length = 2; // low surrogate\n  }\n  return [text.slice(index, index + length), length];\n};\n\nexport const charSplit = (text: string) => {\n  const chars: string[] = [];\n\n  for (let idx = 0, len = text.length; idx < len; ) {\n    const [c, cLen] = charAtIndex(text, idx);\n    chars.push(c);\n    idx += cLen;\n  }\n\n  return chars;\n};\n\nconst buildWordBreakRegex = (wordBreaks: string[]) => {\n  const newlineCharUnion = escapedNewlineChars.join('|');\n\n  const escapedRules: string[] = ['$'];\n  for (let idx = 0, len = wordBreaks.length; idx < len; idx++) {\n    const wordBreak = wordBreaks[idx];\n    if (isNewlineChar(wordBreak)) {\n      throw new TypeError(`\\`wordBreak\\` must not include ${newlineCharUnion}`);\n    }\n    escapedRules.push(wordBreak === '' ? '.' : escapeRegExp(wordBreak));\n  }\n\n  const breakRules = escapedRules.join('|');\n  return new RegExp(`(${newlineCharUnion})|((.*?)(${breakRules}))`, 'gm');\n};\n\nexport const breakTextIntoLines = (\n  text: string,\n  wordBreaks: string[],\n  maxWidth: number,\n  computeWidthOfText: (t: string) => number,\n): string[] => {\n  const regex = buildWordBreakRegex(wordBreaks);\n\n  const words = cleanText(text).match(regex)!;\n\n  let currLine = '';\n  let currWidth = 0;\n  const lines: string[] = [];\n\n  const pushCurrLine = () => {\n    if (currLine !== '') lines.push(currLine);\n    currLine = '';\n    currWidth = 0;\n  };\n\n  for (let idx = 0, len = words.length; idx < len; idx++) {\n    const word = words[idx];\n    if (isNewlineChar(word)) {\n      pushCurrLine();\n    } else {\n      const width = computeWidthOfText(word);\n      if (currWidth + width > maxWidth) pushCurrLine();\n      currLine += word;\n      currWidth += width;\n    }\n  }\n  pushCurrLine();\n\n  return lines;\n};\n\n// See section \"7.9.4 Dates\" of the PDF specification\nconst dateRegex = /^D:(\\d\\d\\d\\d)(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?([+\\-Z])?(\\d\\d)?'?(\\d\\d)?'?$/;\n\nexport const parseDate = (dateStr: string): Date | undefined => {\n  const match = dateStr.match(dateRegex);\n\n  if (!match) return undefined;\n\n  const [\n    ,\n    year,\n    month = '01',\n    day = '01',\n    hours = '00',\n    mins = '00',\n    secs = '00',\n    offsetSign = 'Z',\n    offsetHours = '00',\n    offsetMins = '00',\n  ] = match;\n\n  // http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15\n  const tzOffset =\n    offsetSign === 'Z' ? 'Z' : `${offsetSign}${offsetHours}:${offsetMins}`;\n  const date = new Date(\n    `${year}-${month}-${day}T${hours}:${mins}:${secs}${tzOffset}`,\n  );\n\n  return date;\n};\n\nexport const findLastMatch = (value: string, regex: RegExp) => {\n  let position = 0;\n  let lastMatch: RegExpMatchArray | undefined;\n  while (position < value.length) {\n    const match = value.substring(position).match(regex);\n    if (!match) return { match: lastMatch, pos: position };\n    lastMatch = match;\n    position += (match.index ?? 0) + match[0].length;\n  }\n  return { match: lastMatch, pos: position };\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAO,IAAM,UAAU,GAAG,SAAC,SAAiB;IAAK,OAAA,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC;AAAvB,CAAuB,CAAC;AAElE,IAAM,WAAW,GAAG,SAAC,SAAiB;IAAK,OAAA,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC;AAAxB,CAAwB,CAAC;AAEpE,IAAM,sBAAsB,GAAG,SAAC,GAAW,EAAE,SAAiB;IACnE,OAAA,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,SAAS,EAAE,GAAG,CAAC,CAAC,WAAW,EAAE;AAAxD,CAAwD,CAAC;AAEpD,IAAM,WAAW,GAAG,SAAC,GAAW;IAAK,OAAA,sBAAsB,CAAC,GAAG,EAAE,CAAC,CAAC;AAA9B,CAA8B,CAAC;AAEpE,IAAM,YAAY,GAAG,SAAC,IAAY;IAAK,OAAA,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC;AAAzB,CAAyB,CAAC;AAEjE,IAAM,eAAe,GAAG,SAAC,GAAW;IAAK,OAAA,YAAY,CAAC,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;AAA/B,CAA+B,CAAC;AAEzE,IAAM,QAAQ,GAAG,SAAC,KAAa,EAAE,MAAc,EAAE,OAAe;IACrE,IAAI,OAAO,GAAG,EAAE,CAAC;IACjB,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,CAAE;QAC/D,OAAO,IAAI,OAAO,CAAC;KACpB;IACD,OAAO,OAAO,GAAG,KAAK,CAAC;AACzB,CAAC,CAAC;AAEK,IAAM,oBAAoB,GAAG,SAClC,GAAW,EACX,MAAkB,EAClB,MAAc;IAEd,IAAM,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;IAC1B,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,EAAE,GAAG,EAAE,CAAE;QACrC,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;KACxC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AAEK,IAAM,eAAe,GAAG,SAAC,MAAc,EAAE,YAAgB;IAAhB,IAAA,iBAAA,KAAA,GAAA;QAAA,eAAA,CAAgB;IAAA;IAC9D,OAAG,MAAM,GAAA,MAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,KAAA,GAAA,CAAA,EAAE,EAAI,YAAY,CAAA,CAAG;AAA7D,CAA6D,CAAC;AAEzD,IAAM,YAAY,GAAG,SAAC,GAAW;IACtC,OAAA,GAAG,CAAC,OAAO,CAAC,qBAAqB,EAAE,MAAM,CAAC;AAA1C,CAA0C,CAAC;AAEtC,IAAM,SAAS,GAAG,SAAC,IAAY;IACpC,OAAA,IAAI,CAAC,OAAO,CAAC,0BAA0B,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC;AAAvE,CAAuE,CAAC;AAEnE,IAAM,mBAAmB,GAAG;IAAC,KAAK;IAAE,KAAK;IAAE,KAAK;IAAE,SAAS;CAAC,CAAC;AAE7D,IAAM,YAAY,GAAG;IAAC,IAAI;IAAE,IAAI;IAAE,IAAI;IAAE,QAAQ;CAAC,CAAC;AAElD,IAAM,aAAa,GAAG,SAAC,IAAY;IAAK,OAAA,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC;AAA7B,CAA6B,CAAC;AAEtE,IAAM,SAAS,GAAG,SAAC,IAAY;IAAK,OAAA,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC;AAA5B,CAA4B,CAAC;AAEjE,IAAM,UAAU,GAAG,SAAC,IAAY;IACrC,OAAA,IAAI,CAAC,OAAO,CAAC,iBAAiB,EAAE,GAAG,CAAC;AAApC,CAAoC,CAAC;AAOhC,IAAM,WAAW,GAAG,SAAC,IAAY,EAAE,KAAa;IACrD,8CAA8C;IAC9C,IAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;IACvC,IAAI,QAAgB,CAAC;IACrB,IAAM,SAAS,GAAG,KAAK,GAAG,CAAC,CAAC;IAC5B,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,IACE,+CAA+C;IAC/C,OAAO,IAAI,MAAM,IACjB,OAAO,IAAI,MAAM,IAAI,iBAAiB;IACtC,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC,4BAA4B;MACpD;QACA,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QACtC,IAAI,QAAQ,IAAI,MAAM,IAAI,QAAQ,IAAI,MAAM,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC,gBAAgB;KAC3E;IACD,OAAO;QAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,GAAG,MAAM,CAAC;QAAE,MAAM;KAAC,CAAC;AACrD,CAAC,CAAC;AAEK,IAAM,SAAS,GAAG,SAAC,IAAY;IACpC,IAAM,KAAK,GAAa,EAAE,CAAC;IAE3B,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAI;QAC1C,IAAA,KAAY,WAAW,CAAC,IAAI,EAAE,GAAG,CAAC,EAAjC,CAAC,GAAA,EAAA,CAAA,EAAA,EAAE,IAAI,GAAA,EAAA,CAAA,EAA0B,CAAC;QACzC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACd,GAAG,IAAI,IAAI,CAAC;KACb;IAED,OAAO,KAAK,CAAC;AACf,CAAC,CAAC;AAEF,IAAM,mBAAmB,GAAG,SAAC,UAAoB;IAC/C,IAAM,gBAAgB,GAAG,mBAAmB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAEvD,IAAM,YAAY,GAAa;QAAC,GAAG;KAAC,CAAC;IACrC,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,UAAU,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,CAAE;QAC3D,IAAM,SAAS,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;QAClC,IAAI,aAAa,CAAC,SAAS,CAAC,EAAE;YAC5B,MAAM,IAAI,SAAS,CAAC,kCAAkC,gBAAkB,CAAC,CAAC;SAC3E;QACD,YAAY,CAAC,IAAI,CAAC,SAAS,KAAK,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC;KACrE;IAED,IAAM,UAAU,GAAG,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAC1C,OAAO,IAAI,MAAM,CAAC,MAAI,gBAAgB,GAAA,cAAY,UAAU,GAAA,IAAI,EAAE,IAAI,CAAC,CAAC;AAC1E,CAAC,CAAC;AAEK,IAAM,kBAAkB,GAAG,SAChC,IAAY,EACZ,UAAoB,EACpB,QAAgB,EAChB,kBAAyC;IAEzC,IAAM,KAAK,GAAG,mBAAmB,CAAC,UAAU,CAAC,CAAC;IAE9C,IAAM,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,KAAK,CAAE,CAAC;IAE5C,IAAI,QAAQ,GAAG,EAAE,CAAC;IAClB,IAAI,SAAS,GAAG,CAAC,CAAC;IAClB,IAAM,KAAK,GAAa,EAAE,CAAC;IAE3B,IAAM,YAAY,GAAG;QACnB,IAAI,QAAQ,KAAK,EAAE,EAAE,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC1C,QAAQ,GAAG,EAAE,CAAC;QACd,SAAS,GAAG,CAAC,CAAC;IAChB,CAAC,CAAC;IAEF,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,CAAE;QACtD,IAAM,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;QACxB,IAAI,aAAa,CAAC,IAAI,CAAC,EAAE;YACvB,YAAY,EAAE,CAAC;SAChB,MAAM;YACL,IAAM,KAAK,GAAG,kBAAkB,CAAC,IAAI,CAAC,CAAC;YACvC,IAAI,SAAS,GAAG,KAAK,GAAG,QAAQ,EAAE,YAAY,EAAE,CAAC;YACjD,QAAQ,IAAI,IAAI,CAAC;YACjB,SAAS,IAAI,KAAK,CAAC;SACpB;KACF;IACD,YAAY,EAAE,CAAC;IAEf,OAAO,KAAK,CAAC;AACf,CAAC,CAAC;AAEF,qDAAqD;AACrD,IAAM,SAAS,GAAG,8EAA8E,CAAC;AAE1F,IAAM,SAAS,GAAG,SAAC,OAAe;IACvC,IAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IAEvC,IAAI,CAAC,KAAK,EAAE,OAAO,SAAS,CAAC;IAI3B,IAAA,IAAI,GASF,KAAK,CAAA,EATH,EACJ,KAQE,KAAK,CAAA,EARK,EAAZ,KAAK,GAAA,OAAA,KAAA,IAAG,IAAI,GAAA,EAAA,EACZ,KAOE,KAAK,CAAA,EAPG,EAAV,GAAG,GAAA,OAAA,KAAA,IAAG,IAAI,GAAA,EAAA,EACV,KAME,KAAK,CAAA,EANK,EAAZ,KAAK,GAAA,OAAA,KAAA,IAAG,IAAI,GAAA,EAAA,EACZ,KAKE,KAAK,CAAA,EALI,EAAX,IAAI,GAAA,OAAA,KAAA,IAAG,IAAI,GAAA,EAAA,EACX,KAIE,KAAK,CAAA,EAJI,EAAX,IAAI,GAAA,OAAA,KAAA,IAAG,IAAI,GAAA,EAAA,EACX,KAGE,KAAK,CAAA,EAHS,EAAhB,UAAU,GAAA,OAAA,KAAA,IAAG,GAAG,GAAA,EAAA,EAChB,KAEE,KAAK,CAAA,EAFW,EAAlB,WAAW,GAAA,OAAA,KAAA,IAAG,IAAI,GAAA,EAAA,EAClB,KACE,KAAK,CAAA,EADU,EAAjB,UAAU,GAAA,OAAA,KAAA,IAAG,IAAI,GAAA,EAAA,CACT;IAEV,gEAAgE;IAChE,IAAM,QAAQ,GACZ,UAAU,KAAK,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAG,UAAU,GAAG,WAAW,GAAA,MAAI,UAAY,CAAC;IACzE,IAAM,IAAI,GAAG,IAAI,IAAI,CAChB,IAAI,GAAA,MAAI,KAAK,GAAA,MAAI,GAAG,GAAA,MAAI,KAAK,GAAA,MAAI,IAAI,GAAA,MAAI,IAAI,GAAG,QAAU,CAC9D,CAAC;IAEF,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AAEK,IAAM,aAAa,GAAG,SAAC,KAAa,EAAE,KAAa;;IACxD,IAAI,QAAQ,GAAG,CAAC,CAAC;IACjB,IAAI,SAAuC,CAAC;IAC5C,MAAO,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAE;QAC9B,IAAM,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACrD,IAAI,CAAC,KAAK,EAAE,OAAO;YAAE,KAAK,EAAE,SAAS;YAAE,GAAG,EAAE,QAAQ;QAAA,CAAE,CAAC;QACvD,SAAS,GAAG,KAAK,CAAC;QAClB,QAAQ,IAAI,CAAA,CAAA,KAAC,KAAK,CAAC,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;KAClD;IACD,OAAO;QAAE,KAAK,EAAE,SAAS;QAAE,GAAG,EAAE,QAAQ;IAAA,CAAE,CAAC;AAC7C,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 275, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 281, "column": 0}, "map": {"version":3,"file":"arrays.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/utils/arrays.ts"],"sourcesContent":["import { decodeFromBase64DataUri } from 'src/utils/base64';\nimport { charFromCode } from 'src/utils/strings';\n\nexport const last = <T>(array: T[]): T => array[array.length - 1];\n\n// export const dropLast = <T>(array: T[]): T[] =>\n// array.slice(0, array.length - 1);\n\nexport const typedArrayFor = (value: string | Uint8Array): Uint8Array => {\n  if (value instanceof Uint8Array) return value;\n  const length = value.length;\n  const typedArray = new Uint8Array(length);\n  for (let idx = 0; idx < length; idx++) {\n    typedArray[idx] = value.charCodeAt(idx);\n  }\n  return typedArray;\n};\n\nexport const mergeIntoTypedArray = (...arrays: (string | Uint8Array)[]) => {\n  const arrayCount = arrays.length;\n\n  const typedArrays: Uint8Array[] = [];\n  for (let idx = 0; idx < arrayCount; idx++) {\n    const element = arrays[idx];\n    typedArrays[idx] =\n      element instanceof Uint8Array ? element : typedArrayFor(element);\n  }\n\n  let totalSize = 0;\n  for (let idx = 0; idx < arrayCount; idx++) {\n    totalSize += arrays[idx].length;\n  }\n\n  const merged = new Uint8Array(totalSize);\n  let offset = 0;\n  for (let arrIdx = 0; arrIdx < arrayCount; arrIdx++) {\n    const arr = typedArrays[arrIdx];\n    for (let byteIdx = 0, arrLen = arr.length; byteIdx < arrLen; byteIdx++) {\n      merged[offset++] = arr[byteIdx];\n    }\n  }\n\n  return merged;\n};\n\nexport const mergeUint8Arrays = (arrays: Uint8Array[]): Uint8Array => {\n  let totalSize = 0;\n  for (let idx = 0, len = arrays.length; idx < len; idx++) {\n    totalSize += arrays[idx].length;\n  }\n\n  const mergedBuffer = new Uint8Array(totalSize);\n  let offset = 0;\n  for (let idx = 0, len = arrays.length; idx < len; idx++) {\n    const array = arrays[idx];\n    mergedBuffer.set(array, offset);\n    offset += array.length;\n  }\n\n  return mergedBuffer;\n};\n\nexport const arrayAsString = (array: Uint8Array | number[]): string => {\n  let str = '';\n  for (let idx = 0, len = array.length; idx < len; idx++) {\n    str += charFromCode(array[idx]);\n  }\n  return str;\n};\n\nexport const byAscendingId = <T extends { id: any }>(a: T, b: T) => a.id - b.id;\n\nexport const sortedUniq = <T>(array: T[], indexer: (elem: T) => any): T[] => {\n  const uniq: T[] = [];\n\n  for (let idx = 0, len = array.length; idx < len; idx++) {\n    const curr = array[idx];\n    const prev = array[idx - 1];\n    if (idx === 0 || indexer(curr) !== indexer(prev)) {\n      uniq.push(curr);\n    }\n  }\n\n  return uniq;\n};\n\n// Arrays and TypedArrays in JS both have .reverse() methods, which would seem\n// to negate the need for this function. However, not all runtimes support this\n// method (e.g. React Native). This function compensates for that fact.\nexport const reverseArray = (array: Uint8Array) => {\n  const arrayLen = array.length;\n  for (let idx = 0, len = Math.floor(arrayLen / 2); idx < len; idx++) {\n    const leftIdx = idx;\n    const rightIdx = arrayLen - idx - 1;\n    const temp = array[idx];\n\n    array[leftIdx] = array[rightIdx];\n    array[rightIdx] = temp;\n  }\n  return array;\n};\n\nexport const sum = (array: number[] | Uint8Array): number => {\n  let total = 0;\n  for (let idx = 0, len = array.length; idx < len; idx++) {\n    total += array[idx];\n  }\n  return total;\n};\n\nexport const range = (start: number, end: number): number[] => {\n  const arr = new Array(end - start);\n  for (let idx = 0, len = arr.length; idx < len; idx++) {\n    arr[idx] = start + idx;\n  }\n  return arr;\n};\n\nexport const pluckIndices = <T>(arr: T[], indices: number[]) => {\n  const plucked = new Array<T>(indices.length);\n  for (let idx = 0, len = indices.length; idx < len; idx++) {\n    plucked[idx] = arr[indices[idx]];\n  }\n  return plucked;\n};\n\nexport const canBeConvertedToUint8Array = (\n  input: any,\n): input is string | ArrayBuffer | Uint8Array =>\n  input instanceof Uint8Array ||\n  input instanceof ArrayBuffer ||\n  typeof input === 'string';\n\nexport const toUint8Array = (input: string | ArrayBuffer | Uint8Array) => {\n  if (typeof input === 'string') {\n    return decodeFromBase64DataUri(input);\n  } else if (input instanceof ArrayBuffer) {\n    return new Uint8Array(input);\n  } else if (input instanceof Uint8Array) {\n    return input;\n  } else {\n    throw new TypeError(\n      '`input` must be one of `string | ArrayBuffer | Uint8Array`',\n    );\n  }\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,OAAO,EAAE,uBAAuB,EAAE,iBAAyB;AAC3D,OAAO,EAAE,YAAY,EAAE,kBAA0B;;;AAE1C,IAAM,IAAI,GAAG,SAAI,KAAU;IAAQ,OAAA,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;AAAvB,CAAuB,CAAC;AAK3D,IAAM,aAAa,GAAG,SAAC,KAA0B;IACtD,IAAI,KAAK,YAAY,UAAU,EAAE,OAAO,KAAK,CAAC;IAC9C,IAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;IAC5B,IAAM,UAAU,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;IAC1C,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,EAAE,GAAG,EAAE,CAAE;QACrC,UAAU,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;KACzC;IACD,OAAO,UAAU,CAAC;AACpB,CAAC,CAAC;AAEK,IAAM,mBAAmB,GAAG;IAAC,IAAA,SAAA,EAAA,CAAkC;QAAlC,IAAA,KAAA,CAAkC,EAAlC,KAAA,UAAA,MAAkC,EAAlC,IAAkC,CAAA;QAAlC,MAAA,CAAA,GAAA,GAAA,SAAA,CAAA,GAAA,CAAkC;;IACpE,IAAM,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC;IAEjC,IAAM,WAAW,GAAiB,EAAE,CAAC;IACrC,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,UAAU,EAAE,GAAG,EAAE,CAAE;QACzC,IAAM,OAAO,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;QAC5B,WAAW,CAAC,GAAG,CAAC,GACd,OAAO,YAAY,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;KACpE;IAED,IAAI,SAAS,GAAG,CAAC,CAAC;IAClB,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,UAAU,EAAE,GAAG,EAAE,CAAE;QACzC,SAAS,IAAI,MAAM,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;KACjC;IAED,IAAM,MAAM,GAAG,IAAI,UAAU,CAAC,SAAS,CAAC,CAAC;IACzC,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,IAAK,IAAI,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,UAAU,EAAE,MAAM,EAAE,CAAE;QAClD,IAAM,GAAG,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC;QAChC,IAAK,IAAI,OAAO,GAAG,CAAC,EAAE,MAAM,GAAG,GAAG,CAAC,MAAM,EAAE,OAAO,GAAG,MAAM,EAAE,OAAO,EAAE,CAAE;YACtE,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,CAAC,OAAO,CAAC,CAAC;SACjC;KACF;IAED,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AAEK,IAAM,gBAAgB,GAAG,SAAC,MAAoB;IACnD,IAAI,SAAS,GAAG,CAAC,CAAC;IAClB,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,CAAE;QACvD,SAAS,IAAI,MAAM,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;KACjC;IAED,IAAM,YAAY,GAAG,IAAI,UAAU,CAAC,SAAS,CAAC,CAAC;IAC/C,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,CAAE;QACvD,IAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;QAC1B,YAAY,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QAChC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC;KACxB;IAED,OAAO,YAAY,CAAC;AACtB,CAAC,CAAC;AAEK,IAAM,aAAa,GAAG,SAAC,KAA4B;IACxD,IAAI,GAAG,GAAG,EAAE,CAAC;IACb,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,CAAE;QACtD,GAAG,6JAAI,eAAA,AAAY,EAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;KACjC;IACD,OAAO,GAAG,CAAC;AACb,CAAC,CAAC;AAEK,IAAM,aAAa,GAAG,SAAwB,CAAI,EAAE,CAAI;IAAK,OAAA,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAAX,CAAW,CAAC;AAEzE,IAAM,UAAU,GAAG,SAAI,KAAU,EAAE,OAAyB;IACjE,IAAM,IAAI,GAAQ,EAAE,CAAC;IAErB,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,CAAE;QACtD,IAAM,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;QACxB,IAAM,IAAI,GAAG,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;QAC5B,IAAI,GAAG,KAAK,CAAC,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,OAAO,CAAC,IAAI,CAAC,EAAE;YAChD,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACjB;KACF;IAED,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AAKK,IAAM,YAAY,GAAG,SAAC,KAAiB;IAC5C,IAAM,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAC;IAC9B,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,CAAE;QAClE,IAAM,OAAO,GAAG,GAAG,CAAC;QACpB,IAAM,QAAQ,GAAG,QAAQ,GAAG,GAAG,GAAG,CAAC,CAAC;QACpC,IAAM,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;QAExB,KAAK,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;QACjC,KAAK,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC;KACxB;IACD,OAAO,KAAK,CAAC;AACf,CAAC,CAAC;AAEK,IAAM,GAAG,GAAG,SAAC,KAA4B;IAC9C,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,CAAE;QACtD,KAAK,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC;KACrB;IACD,OAAO,KAAK,CAAC;AACf,CAAC,CAAC;AAEK,IAAM,KAAK,GAAG,SAAC,KAAa,EAAE,GAAW;IAC9C,IAAM,GAAG,GAAG,IAAI,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC;IACnC,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,GAAG,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,CAAE;QACpD,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,GAAG,GAAG,CAAC;KACxB;IACD,OAAO,GAAG,CAAC;AACb,CAAC,CAAC;AAEK,IAAM,YAAY,GAAG,SAAI,GAAQ,EAAE,OAAiB;IACzD,IAAM,OAAO,GAAG,IAAI,KAAK,CAAI,OAAO,CAAC,MAAM,CAAC,CAAC;IAC7C,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,OAAO,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,CAAE;QACxD,OAAO,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;KAClC;IACD,OAAO,OAAO,CAAC;AACjB,CAAC,CAAC;AAEK,IAAM,0BAA0B,GAAG,SACxC,KAAU;IAEV,OAAA,KAAK,YAAY,UAAU,IAC3B,KAAK,YAAY,WAAW,IAC5B,OAAO,KAAK,KAAK,QAAQ;AAFzB,CAEyB,CAAC;AAErB,IAAM,YAAY,GAAG,SAAC,KAAwC;IACnE,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,+JAAO,0BAAA,AAAuB,EAAC,KAAK,CAAC,CAAC;KACvC,MAAM,IAAI,KAAK,YAAY,WAAW,EAAE;QACvC,OAAO,IAAI,UAAU,CAAC,KAAK,CAAC,CAAC;KAC9B,MAAM,IAAI,KAAK,YAAY,UAAU,EAAE;QACtC,OAAO,KAAK,CAAC;KACd,MAAM;QACL,MAAM,IAAI,SAAS,CACjB,4DAA4D,CAC7D,CAAC;KACH;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 418, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 424, "column": 0}, "map": {"version":3,"file":"async.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/utils/async.ts"],"sourcesContent":["/**\n * Returns a Promise that resolves after at least one tick of the\n * Macro Task Queue occurs.\n */\nexport const waitForTick = (): Promise<void> =>\n  new Promise((resolve) => {\n    setTimeout(() => resolve(), 0);\n  });\n"],"names":[],"mappings":"AAAA;;;GAGG;;;AACI,IAAM,WAAW,GAAG;IACzB,OAAA,IAAI,OAAO,CAAC,SAAC,OAAO;QAClB,UAAU,CAAC;YAAM,OAAA,OAAO,EAAE;QAAT,CAAS,EAAE,CAAC,CAAC,CAAC;IACjC,CAAC,CAAC;AAFF,CAEE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 437, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 443, "column": 0}, "map": {"version":3,"file":"unicode.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/utils/unicode.ts"],"sourcesContent":["import { toHexString } from 'src/utils/strings';\n\n/**\n * Encodes a string to UTF-8.\n *\n * @param input The string to be encoded.\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be added\n *                      to the start of the encoding. (default `true`)\n * @returns A Uint8Array containing the UTF-8 encoding of the input string.\n *\n * -----------------------------------------------------------------------------\n *\n * JavaScript strings are composed of Unicode code points. Code points are\n * integers in the range 0 to 1,114,111 (0x10FFFF). When serializing a string,\n * it must be encoded as a sequence of words. A word is typically 8, 16, or 32\n * bytes in size. As such, Unicode defines three encoding forms: UTF-8, UTF-16,\n * and UTF-32. These encoding forms are described in the Unicode standard [1].\n * This function implements the UTF-8 encoding form.\n *\n * -----------------------------------------------------------------------------\n *\n * In UTF-8, each code point is mapped to a sequence of 1, 2, 3, or 4 bytes.\n * Note that the logic which defines this mapping is slightly convoluted, and\n * not as straightforward as the mapping logic for UTF-16 or UTF-32. The UTF-8\n * mapping logic is as follows [2]:\n *\n * â€¢ If a code point is in the range U+0000..U+007F, then view it as a 7-bit\n *   integer: 0bxxxxxxx. Map the code point to 1 byte with the first high order\n *   bit set to 0:\n *\n *       b1=0b0xxxxxxx\n *\n * â€¢ If a code point is in the range U+0080..U+07FF, then view it as an 11-bit\n *   integer: 0byyyyyxxxxxx. Map the code point to 2 bytes with the first 5 bits\n *   of the code point stored in the first byte, and the last 6 bits stored in\n *   the second byte:\n *\n *       b1=0b110yyyyy    b2=0b10xxxxxx\n *\n * â€¢ If a code point is in the range U+0800..U+FFFF, then view it as a 16-bit\n *   integer, 0bzzzzyyyyyyxxxxxx. Map the code point to 3 bytes with the first\n *   4 bits stored in the first byte, the next 6 bits stored in the second byte,\n *   and the last 6 bits in the third byte:\n *\n *       b1=0b1110zzzz    b2=0b10yyyyyy    b3=0b10xxxxxx\n *\n * â€¢ If a code point is in the range U+10000...U+10FFFF, then view it as a\n *   21-bit integer, 0bvvvzzzzzzyyyyyyxxxxxx. Map the code point to 4 bytes with\n *   the first 3 bits stored in the first byte, the next 6 bits stored in the\n *   second byte, the next 6 bits stored in the third byte, and the last 6 bits\n *   stored in the fourth byte:\n *\n *       b1=0b11110xxx    b2=0b10zzzzzz    b3=0b10yyyyyy    b4=0b10xxxxxx\n *\n * -----------------------------------------------------------------------------\n *\n * It is important to note, when iterating through the code points of a string\n * in JavaScript, that if a character is encoded as a surrogate pair it will\n * increase the string's length by 2 instead of 1 [4]. For example:\n *\n * ```\n * > 'a'.length\n * 1\n * > 'ðŸ’©'.length\n * 2\n * > 'èªž'.length\n * 1\n * > 'aðŸ’©èªž'.length\n * 4\n * ```\n *\n * The results of the above example are explained by the fact that the\n * characters 'a' and 'èªž' are not represented by surrogate pairs, but 'ðŸ’©' is.\n *\n * Because of this idiosyncrasy in JavaScript's string implementation and APIs,\n * we must \"jump\" an extra index after encoding a character as a surrogate\n * pair. In practice, this means we must increment the index of our for loop by\n * 2 if we encode a surrogate pair, and 1 in all other cases.\n *\n * -----------------------------------------------------------------------------\n *\n * References:\n *   - [1] https://www.unicode.org/versions/Unicode12.0.0/UnicodeStandard-12.0.pdf\n *         3.9  Unicode Encoding Forms - UTF-8\n *   - [2] http://www.herongyang.com/Unicode/UTF-8-UTF-8-Encoding.html\n *   - [3] http://www.herongyang.com/Unicode/UTF-8-UTF-8-Encoding-Algorithm.html\n *   - [4] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#Description\n *\n */\nexport const utf8Encode = (input: string, byteOrderMark = true): Uint8Array => {\n  const encoded = [];\n\n  if (byteOrderMark) encoded.push(0xef, 0xbb, 0xbf);\n\n  for (let idx = 0, len = input.length; idx < len; ) {\n    const codePoint = input.codePointAt(idx)!;\n\n    // One byte encoding\n    if (codePoint < 0x80) {\n      const byte1 = codePoint & 0x7f;\n      encoded.push(byte1);\n      idx += 1;\n    }\n\n    // Two byte encoding\n    else if (codePoint < 0x0800) {\n      const byte1 = ((codePoint >> 6) & 0x1f) | 0xc0;\n      const byte2 = (codePoint & 0x3f) | 0x80;\n      encoded.push(byte1, byte2);\n      idx += 1;\n    }\n\n    // Three byte encoding\n    else if (codePoint < 0x010000) {\n      const byte1 = ((codePoint >> 12) & 0x0f) | 0xe0;\n      const byte2 = ((codePoint >> 6) & 0x3f) | 0x80;\n      const byte3 = (codePoint & 0x3f) | 0x80;\n      encoded.push(byte1, byte2, byte3);\n      idx += 1;\n    }\n\n    // Four byte encoding (surrogate pair)\n    else if (codePoint < 0x110000) {\n      const byte1 = ((codePoint >> 18) & 0x07) | 0xf0;\n      const byte2 = ((codePoint >> 12) & 0x3f) | 0x80;\n      const byte3 = ((codePoint >> 6) & 0x3f) | 0x80;\n      const byte4 = ((codePoint >> 0) & 0x3f) | 0x80;\n      encoded.push(byte1, byte2, byte3, byte4);\n      idx += 2;\n    }\n\n    // Should never reach this case\n    else throw new Error(`Invalid code point: 0x${toHexString(codePoint)}`);\n  }\n\n  return new Uint8Array(encoded);\n};\n\n/**\n * Encodes a string to UTF-16.\n *\n * @param input The string to be encoded.\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be added\n *                      to the start of the encoding. (default `true`)\n * @returns A Uint16Array containing the UTF-16 encoding of the input string.\n *\n * -----------------------------------------------------------------------------\n *\n * JavaScript strings are composed of Unicode code points. Code points are\n * integers in the range 0 to 1,114,111 (0x10FFFF). When serializing a string,\n * it must be encoded as a sequence of words. A word is typically 8, 16, or 32\n * bytes in size. As such, Unicode defines three encoding forms: UTF-8, UTF-16,\n * and UTF-32. These encoding forms are described in the Unicode standard [1].\n * This function implements the UTF-16 encoding form.\n *\n * -----------------------------------------------------------------------------\n *\n * In UTF-16, each code point is mapped to one or two 16-bit integers. The\n * UTF-16 mapping logic is as follows [2]:\n *\n * â€¢ If a code point is in the range U+0000..U+FFFF, then map the code point to\n *   a 16-bit integer with the most significant byte first.\n *\n * â€¢ If a code point is in the range U+10000..U+10000, then map the code point\n *   to two 16-bit integers. The first integer should contain the high surrogate\n *   and the second integer should contain the low surrogate. Both surrogates\n *   should be written with the most significant byte first.\n *\n * -----------------------------------------------------------------------------\n *\n * It is important to note, when iterating through the code points of a string\n * in JavaScript, that if a character is encoded as a surrogate pair it will\n * increase the string's length by 2 instead of 1 [4]. For example:\n *\n * ```\n * > 'a'.length\n * 1\n * > 'ðŸ’©'.length\n * 2\n * > 'èªž'.length\n * 1\n * > 'aðŸ’©èªž'.length\n * 4\n * ```\n *\n * The results of the above example are explained by the fact that the\n * characters 'a' and 'èªž' are not represented by surrogate pairs, but 'ðŸ’©' is.\n *\n * Because of this idiosyncrasy in JavaScript's string implementation and APIs,\n * we must \"jump\" an extra index after encoding a character as a surrogate\n * pair. In practice, this means we must increment the index of our for loop by\n * 2 if we encode a surrogate pair, and 1 in all other cases.\n *\n * -----------------------------------------------------------------------------\n *\n * References:\n *   - [1] https://www.unicode.org/versions/Unicode12.0.0/UnicodeStandard-12.0.pdf\n *         3.9  Unicode Encoding Forms - UTF-8\n *   - [2] http://www.herongyang.com/Unicode/UTF-16-UTF-16-Encoding.html\n *   - [3] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#Description\n *\n */\nexport const utf16Encode = (\n  input: string,\n  byteOrderMark = true,\n): Uint16Array => {\n  const encoded = [];\n\n  if (byteOrderMark) encoded.push(0xfeff);\n\n  for (let idx = 0, len = input.length; idx < len; ) {\n    const codePoint = input.codePointAt(idx)!;\n\n    // Two byte encoding\n    if (codePoint < 0x010000) {\n      encoded.push(codePoint);\n      idx += 1;\n    }\n\n    // Four byte encoding (surrogate pair)\n    else if (codePoint < 0x110000) {\n      encoded.push(highSurrogate(codePoint), lowSurrogate(codePoint));\n      idx += 2;\n    }\n\n    // Should never reach this case\n    else throw new Error(`Invalid code point: 0x${toHexString(codePoint)}`);\n  }\n\n  return new Uint16Array(encoded);\n};\n\n/**\n * Returns `true` if the `codePoint` is within the\n * Basic Multilingual Plane (BMP). Code points inside the BMP are not encoded\n * with surrogate pairs.\n * @param codePoint The code point to be evaluated.\n *\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\n */\nexport const isWithinBMP = (codePoint: number) =>\n  codePoint >= 0 && codePoint <= 0xffff;\n\n/**\n * Returns `true` if the given `codePoint` is valid and must be represented\n * with a surrogate pair when encoded.\n * @param codePoint The code point to be evaluated.\n *\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\n */\nexport const hasSurrogates = (codePoint: number) =>\n  codePoint >= 0x010000 && codePoint <= 0x10ffff;\n\n// From Unicode 3.0 spec, section 3.7:\n//   http://unicode.org/versions/Unicode3.0.0/ch03.pdf\nexport const highSurrogate = (codePoint: number) =>\n  Math.floor((codePoint - 0x10000) / 0x400) + 0xd800;\n\n// From Unicode 3.0 spec, section 3.7:\n//   http://unicode.org/versions/Unicode3.0.0/ch03.pdf\nexport const lowSurrogate = (codePoint: number) =>\n  ((codePoint - 0x10000) % 0x400) + 0xdc00;\n\nenum ByteOrder {\n  BigEndian = 'BigEndian',\n  LittleEndian = 'LittleEndian',\n}\n\nconst REPLACEMENT = 'ï¿½'.codePointAt(0)!;\n\n/**\n * Decodes a Uint8Array of data to a string using UTF-16.\n *\n * Note that this function attempts to recover from erronous input by\n * inserting the replacement character (ï¿½) to mark invalid code points\n * and surrogate pairs.\n *\n * @param input A Uint8Array containing UTF-16 encoded data\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be read\n *                      at the start of the encoding. (default `true`)\n * @returns The decoded string.\n */\nexport const utf16Decode = (\n  input: Uint8Array,\n  byteOrderMark = true,\n): string => {\n  // Need at least 2 bytes of data in UTF-16 encodings\n  if (input.length <= 1) return String.fromCodePoint(REPLACEMENT);\n\n  const byteOrder = byteOrderMark ? readBOM(input) : ByteOrder.BigEndian;\n\n  // Skip byte order mark if needed\n  let idx = byteOrderMark ? 2 : 0;\n\n  const codePoints: number[] = [];\n\n  while (input.length - idx >= 2) {\n    const first = decodeValues(input[idx++], input[idx++], byteOrder);\n\n    if (isHighSurrogate(first)) {\n      if (input.length - idx < 2) {\n        // Need at least 2 bytes left for the low surrogate that is required\n        codePoints.push(REPLACEMENT);\n      } else {\n        const second = decodeValues(input[idx++], input[idx++], byteOrder);\n        if (isLowSurrogate(second)) {\n          codePoints.push(first, second);\n        } else {\n          // Low surrogates should always follow high surrogates\n          codePoints.push(REPLACEMENT);\n        }\n      }\n    } else if (isLowSurrogate(first)) {\n      // High surrogates should always come first since `decodeValues()`\n      // accounts for the byte ordering\n      idx += 2;\n      codePoints.push(REPLACEMENT);\n    } else {\n      codePoints.push(first);\n    }\n  }\n\n  // There shouldn't be extra byte(s) left over\n  if (idx < input.length) codePoints.push(REPLACEMENT);\n\n  return String.fromCodePoint(...codePoints);\n};\n\n/**\n * Returns `true` if the given `codePoint` is a high surrogate.\n * @param codePoint The code point to be evaluated.\n *\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\n */\nconst isHighSurrogate = (codePoint: number) =>\n  codePoint >= 0xd800 && codePoint <= 0xdbff;\n\n/**\n * Returns `true` if the given `codePoint` is a low surrogate.\n * @param codePoint The code point to be evaluated.\n *\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\n */\nconst isLowSurrogate = (codePoint: number) =>\n  codePoint >= 0xdc00 && codePoint <= 0xdfff;\n\n/**\n * Decodes the given utf-16 values first and second using the specified\n * byte order.\n * @param first The first byte of the encoding.\n * @param second The second byte of the encoding.\n * @param byteOrder The byte order of the encoding.\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Examples\n */\nconst decodeValues = (first: number, second: number, byteOrder: ByteOrder) => {\n  // Append the binary representation of the preceding byte by shifting the\n  // first one 8 to the left and than applying a bitwise or-operator to append\n  // the second one.\n  if (byteOrder === ByteOrder.LittleEndian) return (second << 8) | first;\n  if (byteOrder === ByteOrder.BigEndian) return (first << 8) | second;\n  throw new Error(`Invalid byteOrder: ${byteOrder}`);\n};\n\n/**\n * Returns whether the given array contains a byte order mark for the\n * UTF-16BE or UTF-16LE encoding. If it has neither, BigEndian is assumed.\n *\n * Reference: https://en.wikipedia.org/wiki/Byte_order_mark#UTF-16\n *\n * @param bytes The byte array to be evaluated.\n */\n// prettier-ignore\nconst readBOM = (bytes: Uint8Array): ByteOrder => (\n    hasUtf16BigEndianBOM(bytes) ? ByteOrder.BigEndian\n  : hasUtf16LittleEndianBOM(bytes) ? ByteOrder.LittleEndian\n  : ByteOrder.BigEndian\n);\n\nconst hasUtf16BigEndianBOM = (bytes: Uint8Array) =>\n  bytes[0] === 0xfe && bytes[1] === 0xff;\n\nconst hasUtf16LittleEndianBOM = (bytes: Uint8Array) =>\n  bytes[0] === 0xff && bytes[1] === 0xfe;\n\nexport const hasUtf16BOM = (bytes: Uint8Array) =>\n  hasUtf16BigEndianBOM(bytes) || hasUtf16LittleEndianBOM(bytes);\n"],"names":[],"mappings":";;;;;;;;;;AAAA,OAAO,EAAE,WAAW,EAAE,kBAA0B;;AAyFzC,IAAM,UAAU,GAAG,SAAC,KAAa,EAAE,aAAoB;IAApB,IAAA,kBAAA,KAAA,GAAA;QAAA,gBAAA,IAAoB;IAAA;IAC5D,IAAM,OAAO,GAAG,EAAE,CAAC;IAEnB,IAAI,aAAa,EAAE,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;IAElD,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAI;QACjD,IAAM,SAAS,GAAG,KAAK,CAAC,WAAW,CAAC,GAAG,CAAE,CAAC;QAE1C,oBAAoB;QACpB,IAAI,SAAS,GAAG,IAAI,EAAE;YACpB,IAAM,KAAK,GAAG,SAAS,GAAG,IAAI,CAAC;YAC/B,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACpB,GAAG,IAAI,CAAC,CAAC;SACV,MAGI,IAAI,SAAS,GAAG,MAAM,EAAE;YAC3B,IAAM,KAAK,GAAG,AAAE,CAAD,QAAU,IAAI,CAAC,CAAC,EAAG,IAAI,CAAC,EAAG,IAAI,CAAC;YAC/C,IAAM,KAAK,GAAI,AAAD,SAAU,GAAG,IAAI,CAAC,EAAG,IAAI,CAAC;YACxC,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;YAC3B,GAAG,IAAI,CAAC,CAAC;SACV,MAGI,IAAI,SAAS,GAAG,QAAQ,EAAE;YAC7B,IAAM,KAAK,GAAG,AAAE,CAAD,QAAU,IAAI,EAAE,CAAC,EAAG,IAAI,CAAC,EAAG,IAAI,CAAC;YAChD,IAAM,KAAK,GAAG,AAAE,CAAD,QAAU,IAAI,CAAC,CAAC,EAAG,IAAI,CAAC,EAAG,IAAI,CAAC;YAC/C,IAAM,KAAK,GAAI,AAAD,SAAU,GAAG,IAAI,CAAC,EAAG,IAAI,CAAC;YACxC,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YAClC,GAAG,IAAI,CAAC,CAAC;SACV,MAGI,IAAI,SAAS,GAAG,QAAQ,EAAE;YAC7B,IAAM,KAAK,GAAG,AAAE,CAAD,QAAU,IAAI,EAAE,CAAC,EAAG,IAAI,CAAC,EAAG,IAAI,CAAC;YAChD,IAAM,KAAK,GAAG,AAAE,CAAD,QAAU,IAAI,EAAE,CAAC,EAAG,IAAI,CAAC,EAAG,IAAI,CAAC;YAChD,IAAM,KAAK,GAAK,AAAF,CAAC,QAAU,IAAI,CAAC,CAAC,EAAG,IAAI,CAAC,EAAG,IAAI,CAAC;YAC/C,IAAM,KAAK,GAAK,AAAF,CAAC,QAAU,IAAI,CAAC,CAAC,EAAG,IAAI,CAAC,EAAG,IAAI,CAAC;YAC/C,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YACzC,GAAG,IAAI,CAAC,CAAC;SACV,MAGI,MAAM,IAAI,KAAK,CAAC,oLAAyB,cAAA,AAAW,EAAC,SAAS,CAAG,CAAC,CAAC;KACzE;IAED,OAAO,IAAI,UAAU,CAAC,OAAO,CAAC,CAAC;AACjC,CAAC,CAAC;AAkEK,IAAM,WAAW,GAAG,SACzB,KAAa,EACb,aAAoB;IAApB,IAAA,kBAAA,KAAA,GAAA;QAAA,gBAAA,IAAoB;IAAA;IAEpB,IAAM,OAAO,GAAG,EAAE,CAAC;IAEnB,IAAI,aAAa,EAAE,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAExC,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAI;QACjD,IAAM,SAAS,GAAG,KAAK,CAAC,WAAW,CAAC,GAAG,CAAE,CAAC;QAE1C,oBAAoB;QACpB,IAAI,SAAS,GAAG,QAAQ,EAAE;YACxB,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YACxB,GAAG,IAAI,CAAC,CAAC;SACV,MAGI,IAAI,SAAS,GAAG,QAAQ,EAAE;YAC7B,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC;YAChE,GAAG,IAAI,CAAC,CAAC;SACV,MAGI,MAAM,IAAI,KAAK,CAAC,4BAAyB,sKAAA,AAAW,EAAC,SAAS,CAAG,CAAC,CAAC;KACzE;IAED,OAAO,IAAI,WAAW,CAAC,OAAO,CAAC,CAAC;AAClC,CAAC,CAAC;AAUK,IAAM,WAAW,GAAG,SAAC,SAAiB;IAC3C,OAAA,SAAS,IAAI,CAAC,IAAI,SAAS,IAAI,MAAM;AAArC,CAAqC,CAAC;AASjC,IAAM,aAAa,GAAG,SAAC,SAAiB;IAC7C,OAAA,SAAS,IAAI,QAAQ,IAAI,SAAS,IAAI,QAAQ;AAA9C,CAA8C,CAAC;AAI1C,IAAM,aAAa,GAAG,SAAC,SAAiB;IAC7C,OAAA,IAAI,CAAC,KAAK,CAAC,CAAC,SAAS,GAAG,OAAO,CAAC,GAAG,KAAK,CAAC,GAAG,MAAM;AAAlD,CAAkD,CAAC;AAI9C,IAAM,YAAY,GAAG,SAAC,SAAiB;IAC5C,OAAA,AAAC,CAAC,SAAS,GAAG,OAAO,CAAC,GAAG,KAAK,CAAC,EAAG,MAAM;AAAxC,CAAwC,CAAC;AAE3C,IAAK,SAGJ;AAHD,CAAA,SAAK,SAAS;IACZ,SAAA,CAAA,YAAA,GAAA,WAAuB,CAAA;IACvB,SAAA,CAAA,eAAA,GAAA,cAA6B,CAAA;AAC/B,CAAC,EAHI,SAAS,IAAA,CAAT,SAAS,GAAA,CAAA,CAAA,GAGb;AAED,IAAM,WAAW,GAAG,GAAG,CAAC,WAAW,CAAC,CAAC,CAAE,CAAC;AAcjC,IAAM,WAAW,GAAG,SACzB,KAAiB,EACjB,aAAoB;IAApB,IAAA,kBAAA,KAAA,GAAA;QAAA,gBAAA,IAAoB;IAAA;IAEpB,oDAAoD;IACpD,IAAI,KAAK,CAAC,MAAM,IAAI,CAAC,EAAE,OAAO,MAAM,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC;IAEhE,IAAM,SAAS,GAAG,aAAa,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC;IAEvE,iCAAiC;IACjC,IAAI,GAAG,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAEhC,IAAM,UAAU,GAAa,EAAE,CAAC;IAEhC,MAAO,KAAK,CAAC,MAAM,GAAG,GAAG,IAAI,CAAC,CAAE;QAC9B,IAAM,KAAK,GAAG,YAAY,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,CAAC,GAAG,EAAE,CAAC,EAAE,SAAS,CAAC,CAAC;QAElE,IAAI,eAAe,CAAC,KAAK,CAAC,EAAE;YAC1B,IAAI,KAAK,CAAC,MAAM,GAAG,GAAG,GAAG,CAAC,EAAE;gBAC1B,oEAAoE;gBACpE,UAAU,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;aAC9B,MAAM;gBACL,IAAM,MAAM,GAAG,YAAY,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,CAAC,GAAG,EAAE,CAAC,EAAE,SAAS,CAAC,CAAC;gBACnE,IAAI,cAAc,CAAC,MAAM,CAAC,EAAE;oBAC1B,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;iBAChC,MAAM;oBACL,sDAAsD;oBACtD,UAAU,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;iBAC9B;aACF;SACF,MAAM,IAAI,cAAc,CAAC,KAAK,CAAC,EAAE;YAChC,kEAAkE;YAClE,iCAAiC;YACjC,GAAG,IAAI,CAAC,CAAC;YACT,UAAU,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;SAC9B,MAAM;YACL,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACxB;KACF;IAED,6CAA6C;IAC7C,IAAI,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,UAAU,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IAErD,OAAO,MAAM,CAAC,aAAa,CAAA,KAAA,CAApB,MAAM,EAAkB,UAAU,EAAE;AAC7C,CAAC,CAAC;AAEF;;;;;GAKG,CACH,IAAM,eAAe,GAAG,SAAC,SAAiB;IACxC,OAAA,SAAS,IAAI,MAAM,IAAI,SAAS,IAAI,MAAM;AAA1C,CAA0C,CAAC;AAE7C;;;;;GAKG,CACH,IAAM,cAAc,GAAG,SAAC,SAAiB;IACvC,OAAA,SAAS,IAAI,MAAM,IAAI,SAAS,IAAI,MAAM;AAA1C,CAA0C,CAAC;AAE7C;;;;;;;GAOG,CACH,IAAM,YAAY,GAAG,SAAC,KAAa,EAAE,MAAc,EAAE,SAAoB;IACvE,yEAAyE;IACzE,4EAA4E;IAC5E,kBAAkB;IAClB,IAAI,SAAS,KAAK,SAAS,CAAC,YAAY,EAAE,OAAO,AAAC,MAAM,IAAI,CAAC,CAAC,EAAG,KAAK,CAAC;IACvE,IAAI,SAAS,KAAK,SAAS,CAAC,SAAS,EAAE,OAAO,AAAC,KAAK,IAAI,CAAC,CAAC,EAAG,MAAM,CAAC;IACpE,MAAM,IAAI,KAAK,CAAC,wBAAsB,SAAW,CAAC,CAAC;AACrD,CAAC,CAAC;AAEF;;;;;;;GAOG,CACH,kBAAkB;AAClB,IAAM,OAAO,GAAG,SAAC,KAAiB;IAAgB,OAAA,AAC9C,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,SAAS,GACjD,uBAAuB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,YAAY,GACvD,SAAS,CAAC,SAAS,CACtB;AAJiD,CAIjD,CAAC;AAEF,IAAM,oBAAoB,GAAG,SAAC,KAAiB;IAC7C,OAAA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI;AAAtC,CAAsC,CAAC;AAEzC,IAAM,uBAAuB,GAAG,SAAC,KAAiB;IAChD,OAAA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI;AAAtC,CAAsC,CAAC;AAElC,IAAM,WAAW,GAAG,SAAC,KAAiB;IAC3C,OAAA,oBAAoB,CAAC,KAAK,CAAC,IAAI,uBAAuB,CAAC,KAAK,CAAC;AAA7D,CAA6D,CAAC","ignoreList":[0]}},
    {"offset": {"line": 616, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 622, "column": 0}, "map": {"version":3,"file":"numbers.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/utils/numbers.ts"],"sourcesContent":["// tslint:disable radix\n\n/**\n * Converts a number to its string representation in decimal. This function\n * differs from simply converting a number to a string with `.toString()`\n * because this function's output string will **not** contain exponential\n * notation.\n *\n * Credit: https://stackoverflow.com/a/46545519\n */\nexport const numberToString = (num: number) => {\n  let numStr = String(num);\n\n  if (Math.abs(num) < 1.0) {\n    const e = parseInt(num.toString().split('e-')[1]);\n    if (e) {\n      const negative = num < 0;\n      if (negative) num *= -1;\n      num *= Math.pow(10, e - 1);\n      numStr = '0.' + new Array(e).join('0') + num.toString().substring(2);\n      if (negative) numStr = '-' + numStr;\n    }\n  } else {\n    let e = parseInt(num.toString().split('+')[1]);\n    if (e > 20) {\n      e -= 20;\n      num /= Math.pow(10, e);\n      numStr = num.toString() + new Array(e + 1).join('0');\n    }\n  }\n\n  return numStr;\n};\n\nexport const sizeInBytes = (n: number) => Math.ceil(n.toString(2).length / 8);\n\n/**\n * Converts a number into its constituent bytes and returns them as\n * a number[].\n *\n * Returns most significant byte as first element in array. It may be necessary\n * to call .reverse() to get the bits in the desired order.\n *\n * Example:\n *   bytesFor(0x02A41E) => [ 0b10, 0b10100100, 0b11110 ]\n *\n * Credit for algorithm: https://stackoverflow.com/a/1936865\n */\nexport const bytesFor = (n: number) => {\n  const bytes = new Uint8Array(sizeInBytes(n));\n  for (let i = 1; i <= bytes.length; i++) {\n    bytes[i - 1] = n >> ((bytes.length - i) * 8);\n  }\n  return bytes;\n};\n"],"names":[],"mappings":"AAAA,uBAAuB;AAEvB;;;;;;;GAOG;;;;;AACI,IAAM,cAAc,GAAG,SAAC,GAAW;IACxC,IAAI,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;IAEzB,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,EAAE;QACvB,IAAM,CAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAClD,IAAI,CAAC,EAAE;YACL,IAAM,QAAQ,GAAG,GAAG,GAAG,CAAC,CAAC;YACzB,IAAI,QAAQ,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC;YACxB,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;YAC3B,MAAM,GAAG,IAAI,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,QAAQ,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YACrE,IAAI,QAAQ,EAAE,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC;SACrC;KACF,MAAM;QACL,IAAI,CAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/C,IAAI,CAAC,GAAG,EAAE,EAAE;YACV,CAAC,IAAI,EAAE,CAAC;YACR,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;YACvB,MAAM,GAAG,GAAG,CAAC,QAAQ,EAAE,GAAG,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SACtD;KACF;IAED,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AAEK,IAAM,WAAW,GAAG,SAAC,CAAS;IAAK,OAAA,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;AAAnC,CAAmC,CAAC;AAcvE,IAAM,QAAQ,GAAG,SAAC,CAAS;IAChC,IAAM,KAAK,GAAG,IAAI,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7C,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE;QACtC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,AAAC,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;KAC9C;IACD,OAAO,KAAK,CAAC;AACf,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 666, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 672, "column": 0}, "map": {"version":3,"file":"errors.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/utils/errors.ts"],"sourcesContent":["export const error = (msg: string) => {\n  throw new Error(msg);\n};\n"],"names":[],"mappings":";;;AAAO,IAAM,KAAK,GAAG,SAAC,GAAW;IAC/B,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC;AACvB,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 678, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 684, "column": 0}, "map": {"version":3,"file":"objects.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/utils/objects.ts"],"sourcesContent":["import { FontNames } from '@pdf-lib/standard-fonts';\n\nexport const values = (obj: any) => Object.keys(obj).map((k) => obj[k]);\n\nexport const StandardFontValues = values(FontNames);\n\nexport const isStandardFont = (input: any): input is FontNames =>\n  StandardFontValues.includes(input);\n\nexport const rectanglesAreEqual = (\n  a: { x: number; y: number; width: number; height: number },\n  b: { x: number; y: number; width: number; height: number },\n) => a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n"],"names":[],"mappings":";;;;;;;AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,yBAAyB,CAAC;;AAE7C,IAAM,MAAM,GAAG,SAAC,GAAQ;IAAK,OAAA,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,SAAC,CAAC;QAAK,OAAA,GAAG,CAAC,CAAC,CAAC;IAAN,CAAM,CAAC;AAAnC,CAAmC,CAAC;AAEjE,IAAM,kBAAkB,GAAG,MAAM,iKAAC,YAAS,CAAC,CAAC;AAE7C,IAAM,cAAc,GAAG,SAAC,KAAU;IACvC,OAAA,kBAAkB,CAAC,QAAQ,CAAC,KAAK,CAAC;AAAlC,CAAkC,CAAC;AAE9B,IAAM,kBAAkB,GAAG,SAChC,CAA0D,EAC1D,CAA0D;IACvD,OAAA,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM;AAA1E,CAA0E,CAAC","ignoreList":[0]}},
    {"offset": {"line": 705, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 711, "column": 0}, "map": {"version":3,"file":"validators.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/utils/validators.ts"],"sourcesContent":["/* tslint:disable:ban-types */\n\nimport { values as objectValues } from 'src/utils/objects';\n\nexport const backtick = (val: any) => `\\`${val}\\``;\nexport const singleQuote = (val: any) => `'${val}'`;\n\ntype Primitive = string | number | boolean | undefined | null;\n\n// prettier-ignore\nconst formatValue = (value: any) => {\n  const type = typeof value;\n  if (type ==='string') return singleQuote(value);\n  else if (type ==='undefined') return backtick(value);\n  else return value;\n};\n\nexport const createValueErrorMsg = (\n  value: any,\n  valueName: string,\n  values: Primitive[],\n) => {\n  const allowedValues = new Array(values.length);\n\n  for (let idx = 0, len = values.length; idx < len; idx++) {\n    const v = values[idx];\n    allowedValues[idx] = formatValue(v);\n  }\n\n  const joinedValues = allowedValues.join(' or ');\n\n  // prettier-ignore\n  return `${backtick(valueName)} must be one of ${joinedValues}, but was actually ${formatValue(value)}`;\n};\n\nexport const assertIsOneOf = (\n  value: any,\n  valueName: string,\n  allowedValues: Primitive[] | { [key: string]: Primitive },\n) => {\n  if (!Array.isArray(allowedValues)) {\n    allowedValues = objectValues(allowedValues);\n  }\n  for (let idx = 0, len = allowedValues.length; idx < len; idx++) {\n    if (value === allowedValues[idx]) return;\n  }\n  throw new TypeError(createValueErrorMsg(value, valueName, allowedValues));\n};\n\nexport const assertIsOneOfOrUndefined = (\n  value: any,\n  valueName: string,\n  allowedValues: Primitive[] | { [key: string]: Primitive },\n) => {\n  if (!Array.isArray(allowedValues)) {\n    allowedValues = objectValues(allowedValues);\n  }\n  assertIsOneOf(value, valueName, allowedValues.concat(undefined));\n};\n\nexport const assertIsSubset = (\n  values: any[],\n  valueName: string,\n  allowedValues: Primitive[] | { [key: string]: Primitive },\n) => {\n  if (!Array.isArray(allowedValues)) {\n    allowedValues = objectValues(allowedValues);\n  }\n  for (let idx = 0, len = values.length; idx < len; idx++) {\n    assertIsOneOf(values[idx], valueName, allowedValues);\n  }\n};\n\nexport const getType = (val: any) => {\n  if (val === null) return 'null';\n  if (val === undefined) return 'undefined';\n  if (typeof val === 'string') return 'string';\n  if (isNaN(val)) return 'NaN';\n  if (typeof val === 'number') return 'number';\n  if (typeof val === 'boolean') return 'boolean';\n  if (typeof val === 'symbol') return 'symbol';\n  if (typeof val === 'bigint') return 'bigint';\n  if (val.constructor && val.constructor.name) return val.constructor.name;\n  if (val.name) return val.name;\n  if (val.constructor) return String(val.constructor);\n  return String(val);\n};\n\nexport type TypeDescriptor =\n  | 'null'\n  | 'undefined'\n  | 'string'\n  | 'number'\n  | 'boolean'\n  | 'symbol'\n  | 'bigint'\n  | DateConstructor\n  | ArrayConstructor\n  | Uint8ArrayConstructor\n  | ArrayBufferConstructor\n  | FunctionConstructor\n  | [Function, string];\n\nexport const isType = (value: any, type: TypeDescriptor) => {\n  if (type === 'null') return value === null;\n  if (type === 'undefined') return value === undefined;\n  if (type === 'string') return typeof value === 'string';\n  if (type === 'number') return typeof value === 'number' && !isNaN(value);\n  if (type === 'boolean') return typeof value === 'boolean';\n  if (type === 'symbol') return typeof value === 'symbol';\n  if (type === 'bigint') return typeof value === 'bigint';\n  if (type === Date) return value instanceof Date;\n  if (type === Array) return value instanceof Array;\n  if (type === Uint8Array) return value instanceof Uint8Array;\n  if (type === ArrayBuffer) return value instanceof ArrayBuffer;\n  if (type === Function) return value instanceof Function;\n  return value instanceof (type as [Function, string])[0];\n};\n\nexport const createTypeErrorMsg = (\n  value: any,\n  valueName: string,\n  types: TypeDescriptor[],\n) => {\n  const allowedTypes = new Array(types.length);\n\n  for (let idx = 0, len = types.length; idx < len; idx++) {\n    const type = types[idx];\n    if (type === 'null') allowedTypes[idx] = backtick('null');\n    if (type === 'undefined') allowedTypes[idx] = backtick('undefined');\n    if (type === 'string') allowedTypes[idx] = backtick('string');\n    else if (type === 'number') allowedTypes[idx] = backtick('number');\n    else if (type === 'boolean') allowedTypes[idx] = backtick('boolean');\n    else if (type === 'symbol') allowedTypes[idx] = backtick('symbol');\n    else if (type === 'bigint') allowedTypes[idx] = backtick('bigint');\n    else if (type === Array) allowedTypes[idx] = backtick('Array');\n    else if (type === Uint8Array) allowedTypes[idx] = backtick('Uint8Array');\n    else if (type === ArrayBuffer) allowedTypes[idx] = backtick('ArrayBuffer');\n    else allowedTypes[idx] = backtick((type as [Function, string])[1]);\n  }\n\n  const joinedTypes = allowedTypes.join(' or ');\n\n  // prettier-ignore\n  return `${backtick(valueName)} must be of type ${joinedTypes}, but was actually of type ${backtick(getType(value))}`;\n};\n\nexport const assertIs = (\n  value: any,\n  valueName: string,\n  types: TypeDescriptor[],\n) => {\n  for (let idx = 0, len = types.length; idx < len; idx++) {\n    if (isType(value, types[idx])) return;\n  }\n  throw new TypeError(createTypeErrorMsg(value, valueName, types));\n};\n\nexport const assertOrUndefined = (\n  value: any,\n  valueName: string,\n  types: TypeDescriptor[],\n) => {\n  assertIs(value, valueName, types.concat('undefined'));\n};\n\nexport const assertEachIs = (\n  values: any[],\n  valueName: string,\n  types: TypeDescriptor[],\n) => {\n  for (let idx = 0, len = values.length; idx < len; idx++) {\n    assertIs(values[idx], valueName, types);\n  }\n};\n\nexport const assertRange = (\n  value: any,\n  valueName: string,\n  min: number,\n  max: number,\n) => {\n  assertIs(value, valueName, ['number']);\n  assertIs(min, 'min', ['number']);\n  assertIs(max, 'max', ['number']);\n  max = Math.max(min, max);\n  if (value < min || value > max) {\n    // prettier-ignore\n    throw new Error(`${backtick(valueName)} must be at least ${min} and at most ${max}, but was actually ${value}`);\n  }\n};\n\nexport const assertRangeOrUndefined = (\n  value: any,\n  valueName: string,\n  min: number,\n  max: number,\n) => {\n  assertIs(value, valueName, ['number', 'undefined']);\n  if (typeof value === 'number') assertRange(value, valueName, min, max);\n};\n\nexport const assertMultiple = (\n  value: any,\n  valueName: string,\n  multiplier: number,\n) => {\n  assertIs(value, valueName, ['number']);\n  if (value % multiplier !== 0) {\n    // prettier-ignore\n    throw new Error(`${backtick(valueName)} must be a multiple of ${multiplier}, but was actually ${value}`);\n  }\n};\n\nexport const assertInteger = (value: any, valueName: string) => {\n  if (!Number.isInteger(value)) {\n    throw new Error(\n      `${backtick(valueName)} must be an integer, but was actually ${value}`,\n    );\n  }\n};\n\nexport const assertPositive = (value: number, valueName: string) => {\n  if (![1, 0].includes(Math.sign(value))) {\n    // prettier-ignore\n    throw new Error(`${backtick(valueName)} must be a positive number or 0, but was actually ${value}`);\n  }\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 887, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 893, "column": 0}, "map": {"version":3,"file":"pdfDocEncoding.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/utils/pdfDocEncoding.ts"],"sourcesContent":["import { toCharCode } from 'src/utils/strings';\n\n// Mapping from PDFDocEncoding to Unicode code point\nconst pdfDocEncodingToUnicode = new Uint16Array(256);\n\n// Initialize the code points which are the same\nfor (let idx = 0; idx < 256; idx++) {\n  pdfDocEncodingToUnicode[idx] = idx;\n}\n\n// Set differences (see \"Table D.2 â€“ PDFDocEncoding Character Set\" of the PDF spec)\npdfDocEncodingToUnicode[0x16] = toCharCode('\\u0017'); // SYNCRONOUS IDLE\npdfDocEncodingToUnicode[0x18] = toCharCode('\\u02D8'); // BREVE\npdfDocEncodingToUnicode[0x19] = toCharCode('\\u02C7'); // CARON\npdfDocEncodingToUnicode[0x1a] = toCharCode('\\u02C6'); // MODIFIER LETTER CIRCUMFLEX ACCENT\npdfDocEncodingToUnicode[0x1b] = toCharCode('\\u02D9'); // DOT ABOVE\npdfDocEncodingToUnicode[0x1c] = toCharCode('\\u02DD'); // DOUBLE ACUTE ACCENT\npdfDocEncodingToUnicode[0x1d] = toCharCode('\\u02DB'); // OGONEK\npdfDocEncodingToUnicode[0x1e] = toCharCode('\\u02DA'); // RING ABOVE\npdfDocEncodingToUnicode[0x1f] = toCharCode('\\u02DC'); // SMALL TILDE\npdfDocEncodingToUnicode[0x7f] = toCharCode('\\uFFFD'); // REPLACEMENT CHARACTER (box with questionmark)\npdfDocEncodingToUnicode[0x80] = toCharCode('\\u2022'); // BULLET\npdfDocEncodingToUnicode[0x81] = toCharCode('\\u2020'); // DAGGER\npdfDocEncodingToUnicode[0x82] = toCharCode('\\u2021'); // DOUBLE DAGGER\npdfDocEncodingToUnicode[0x83] = toCharCode('\\u2026'); // HORIZONTAL ELLIPSIS\npdfDocEncodingToUnicode[0x84] = toCharCode('\\u2014'); // EM DASH\npdfDocEncodingToUnicode[0x85] = toCharCode('\\u2013'); // EN DASH\npdfDocEncodingToUnicode[0x86] = toCharCode('\\u0192'); // LATIN SMALL LETTER SCRIPT F\npdfDocEncodingToUnicode[0x87] = toCharCode('\\u2044'); // FRACTION SLASH (solidus)\npdfDocEncodingToUnicode[0x88] = toCharCode('\\u2039'); // SINGLE LEFT-POINTING ANGLE QUOTATION MARK\npdfDocEncodingToUnicode[0x89] = toCharCode('\\u203A'); // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK\npdfDocEncodingToUnicode[0x8a] = toCharCode('\\u2212'); // MINUS SIGN\npdfDocEncodingToUnicode[0x8b] = toCharCode('\\u2030'); // PER MILLE SIGN\npdfDocEncodingToUnicode[0x8c] = toCharCode('\\u201E'); // DOUBLE LOW-9 QUOTATION MARK (quotedblbase)\npdfDocEncodingToUnicode[0x8d] = toCharCode('\\u201C'); // LEFT DOUBLE QUOTATION MARK (quotedblleft)\npdfDocEncodingToUnicode[0x8e] = toCharCode('\\u201D'); // RIGHT DOUBLE QUOTATION MARK (quotedblright)\npdfDocEncodingToUnicode[0x8f] = toCharCode('\\u2018'); // LEFT SINGLE QUOTATION MARK (quoteleft)\npdfDocEncodingToUnicode[0x90] = toCharCode('\\u2019'); // RIGHT SINGLE QUOTATION MARK (quoteright)\npdfDocEncodingToUnicode[0x91] = toCharCode('\\u201A'); // SINGLE LOW-9 QUOTATION MARK (quotesinglbase)\npdfDocEncodingToUnicode[0x92] = toCharCode('\\u2122'); // TRADE MARK SIGN\npdfDocEncodingToUnicode[0x93] = toCharCode('\\uFB01'); // LATIN SMALL LIGATURE FI\npdfDocEncodingToUnicode[0x94] = toCharCode('\\uFB02'); // LATIN SMALL LIGATURE FL\npdfDocEncodingToUnicode[0x95] = toCharCode('\\u0141'); // LATIN CAPITAL LETTER L WITH STROKE\npdfDocEncodingToUnicode[0x96] = toCharCode('\\u0152'); // LATIN CAPITAL LIGATURE OE\npdfDocEncodingToUnicode[0x97] = toCharCode('\\u0160'); // LATIN CAPITAL LETTER S WITH CARON\npdfDocEncodingToUnicode[0x98] = toCharCode('\\u0178'); // LATIN CAPITAL LETTER Y WITH DIAERESIS\npdfDocEncodingToUnicode[0x99] = toCharCode('\\u017D'); // LATIN CAPITAL LETTER Z WITH CARON\npdfDocEncodingToUnicode[0x9a] = toCharCode('\\u0131'); // LATIN SMALL LETTER DOTLESS I\npdfDocEncodingToUnicode[0x9b] = toCharCode('\\u0142'); // LATIN SMALL LETTER L WITH STROKE\npdfDocEncodingToUnicode[0x9c] = toCharCode('\\u0153'); // LATIN SMALL LIGATURE OE\npdfDocEncodingToUnicode[0x9d] = toCharCode('\\u0161'); // LATIN SMALL LETTER S WITH CARON\npdfDocEncodingToUnicode[0x9e] = toCharCode('\\u017E'); // LATIN SMALL LETTER Z WITH CARON\npdfDocEncodingToUnicode[0x9f] = toCharCode('\\uFFFD'); // REPLACEMENT CHARACTER (box with questionmark)\npdfDocEncodingToUnicode[0xa0] = toCharCode('\\u20AC'); // EURO SIGN\npdfDocEncodingToUnicode[0xad] = toCharCode('\\uFFFD'); // REPLACEMENT CHARACTER (box with questionmark)\n\n/**\n * Decode a byte array into a string using PDFDocEncoding.\n *\n * @param bytes a byte array (decimal representation) containing a string\n *              encoded with PDFDocEncoding.\n */\nexport const pdfDocEncodingDecode = (bytes: Uint8Array): string => {\n  const codePoints = new Array(bytes.length);\n  for (let idx = 0, len = bytes.length; idx < len; idx++) {\n    codePoints[idx] = pdfDocEncodingToUnicode[bytes[idx]];\n  }\n  return String.fromCodePoint(...codePoints);\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 956, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 962, "column": 0}, "map": {"version":3,"file":"Cache.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/utils/Cache.ts"],"sourcesContent":["class Cache<T> {\n  static readonly populatedBy = <T>(populate: () => T) => new Cache(populate);\n\n  private readonly populate: () => T;\n  private value: T | undefined;\n\n  private constructor(populate: () => T) {\n    this.populate = populate;\n    this.value = undefined;\n  }\n\n  getValue(): T | undefined {\n    return this.value;\n  }\n\n  access(): T {\n    if (!this.value) this.value = this.populate();\n    return this.value;\n  }\n\n  invalidate(): void {\n    this.value = undefined;\n  }\n}\n\nexport default Cache;\n"],"names":[],"mappings":";;;AAAA,IAAA,QAAA;IAME,SAAA,MAAoB,QAAiB;QACnC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;IACzB,CAAC;IAED,MAAA,SAAA,CAAA,QAAQ,GAAR;QACE,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED,MAAA,SAAA,CAAA,MAAM,GAAN;QACE,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;QAC9C,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED,MAAA,SAAA,CAAA,UAAU,GAAV;QACE,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;IACzB,CAAC;IArBe,MAAA,WAAW,GAAG,SAAI,QAAiB;QAAK,OAAA,IAAI,KAAK,CAAC,QAAQ,CAAC;IAAnB,CAAmB,CAAC;IAsB9E,OAAA,KAAC;CAAA,AAvBD,IAuBC;uCAEc,KAAK,CAAC","ignoreList":[0]}},
    {"offset": {"line": 987, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 993, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/utils/index.ts"],"sourcesContent":["export * from 'src/utils/arrays';\nexport * from 'src/utils/async';\nexport * from 'src/utils/strings';\nexport * from 'src/utils/unicode';\nexport * from 'src/utils/numbers';\nexport * from 'src/utils/errors';\nexport * from 'src/utils/base64';\nexport * from 'src/utils/objects';\nexport * from 'src/utils/validators';\nexport * from 'src/utils/pdfDocEncoding';\nexport { default as Cache } from 'src/utils/Cache';\n"],"names":[],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 1006, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1041, "column": 0}, "map": {"version":3,"file":"rng.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/utils/rng.ts"],"sourcesContent":["/**\n * Generates a pseudo random number. Although it is not cryptographically secure\n * and uniformly distributed, it is not a concern for the intended use-case,\n * which is to generate distinct numbers.\n *\n * Credit: https://stackoverflow.com/a/19303725/10254049\n */\nexport class SimpleRNG {\n  static withSeed = (seed: number) => new SimpleRNG(seed);\n\n  private seed: number;\n\n  private constructor(seed: number) {\n    this.seed = seed;\n  }\n\n  nextInt(): number {\n    const x = Math.sin(this.seed++) * 10000;\n    return x - Math.floor(x);\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;GAMG;;;AACH,IAAA,YAAA;IAKE,SAAA,UAAoB,IAAY;QAC9B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IACnB,CAAC;IAED,UAAA,SAAA,CAAA,OAAO,GAAP;QACE,IAAM,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,GAAG,KAAK,CAAC;QACxC,OAAO,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3B,CAAC;IAXM,UAAA,QAAQ,GAAG,SAAC,IAAY;QAAK,OAAA,IAAI,SAAS,CAAC,IAAI,CAAC;IAAnB,CAAmB,CAAC;IAY1D,OAAA,SAAC;CAAA,AAbD,IAaC","ignoreList":[0]}},
    {"offset": {"line": 1065, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1071, "column": 0}, "map": {"version":3,"file":"png.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/utils/png.ts"],"sourcesContent":["import UPNG from '@pdf-lib/upng';\n\nconst getImageType = (ctype: number) => {\n  if (ctype === 0) return PngType.Greyscale;\n  if (ctype === 2) return PngType.Truecolour;\n  if (ctype === 3) return PngType.IndexedColour;\n  if (ctype === 4) return PngType.GreyscaleWithAlpha;\n  if (ctype === 6) return PngType.TruecolourWithAlpha;\n  throw new Error(`Unknown color type: ${ctype}`);\n};\n\nconst splitAlphaChannel = (rgbaChannel: Uint8Array) => {\n  const pixelCount = Math.floor(rgbaChannel.length / 4);\n\n  const rgbChannel = new Uint8Array(pixelCount * 3);\n  const alphaChannel = new Uint8Array(pixelCount * 1);\n\n  let rgbaOffset = 0;\n  let rgbOffset = 0;\n  let alphaOffset = 0;\n\n  while (rgbaOffset < rgbaChannel.length) {\n    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];\n    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];\n    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];\n    alphaChannel[alphaOffset++] = rgbaChannel[rgbaOffset++];\n  }\n\n  return { rgbChannel, alphaChannel };\n};\n\nexport enum PngType {\n  Greyscale = 'Greyscale',\n  Truecolour = 'Truecolour',\n  IndexedColour = 'IndexedColour',\n  GreyscaleWithAlpha = 'GreyscaleWithAlpha',\n  TruecolourWithAlpha = 'TruecolourWithAlpha',\n}\n\nexport class PNG {\n  static load = (pngData: Uint8Array) => new PNG(pngData);\n\n  readonly rgbChannel: Uint8Array;\n  readonly alphaChannel?: Uint8Array;\n  readonly type: PngType;\n  readonly width: number;\n  readonly height: number;\n  readonly bitsPerComponent: number;\n\n  private constructor(pngData: Uint8Array) {\n    const upng = UPNG.decode(pngData);\n    const frames = UPNG.toRGBA8(upng);\n\n    if (frames.length > 1) throw new Error(`Animated PNGs are not supported`);\n\n    const frame = new Uint8Array(frames[0]);\n    const { rgbChannel, alphaChannel } = splitAlphaChannel(frame);\n\n    this.rgbChannel = rgbChannel;\n\n    const hasAlphaValues = alphaChannel.some((a) => a < 255);\n    if (hasAlphaValues) this.alphaChannel = alphaChannel;\n\n    this.type = getImageType(upng.ctype);\n\n    this.width = upng.width;\n    this.height = upng.height;\n    this.bitsPerComponent = 8;\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1135, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1316, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/es/types/index.js"],"sourcesContent":["//# sourceMappingURL=index.js.map"],"names":[],"mappings":"AAAA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 1317, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1323, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file://D%3A/Prana/prana_client/node_modules/pdf-lib/src/index.ts"],"sourcesContent":["export * from 'src/api/index';\nexport * from 'src/core/index';\nexport * from 'src/types/index';\nexport * from 'src/utils/index';\n"],"names":[],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 1329, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}