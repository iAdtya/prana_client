module.exports = {

"[project]/node_modules/unstructured-client/lib/url.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pathToFunc = void 0;
const hasOwn = Object.prototype.hasOwnProperty;
function pathToFunc(pathPattern, options) {
    const paramRE = /\{([a-zA-Z0-9_]+?)\}/g;
    return function buildURLPath(params = {}) {
        return pathPattern.replace(paramRE, function(_, placeholder) {
            if (!hasOwn.call(params, placeholder)) {
                throw new Error(`Parameter '${placeholder}' is required`);
            }
            const value = params[placeholder];
            if (typeof value !== "string" && typeof value !== "number") {
                throw new Error(`Parameter '${placeholder}' must be a string or number`);
            }
            return (options === null || options === void 0 ? void 0 : options.charEncoding) === "percent" ? encodeURIComponent(`${value}`) : `${value}`;
        });
    };
}
exports.pathToFunc = pathToFunc; //# sourceMappingURL=url.js.map
}}),
"[project]/node_modules/unstructured-client/lib/config.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SDK_METADATA = exports.serverURLFromOptions = exports.ServerList = exports.ServerDevelopment = exports.ServerFreeApi = exports.ServerSaasApi = void 0;
const url_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/url.js [app-rsc] (ecmascript)");
/**
 * Serverless SaaS API
 */ exports.ServerSaasApi = "saas-api";
/**
 * Hosted API Free
 */ exports.ServerFreeApi = "free-api";
/**
 * Development server
 */ exports.ServerDevelopment = "development";
/**
 * Contains the list of servers available to the SDK
 */ exports.ServerList = {
    [exports.ServerSaasApi]: "https://api.unstructuredapp.io",
    [exports.ServerFreeApi]: "https://api.unstructured.io",
    [exports.ServerDevelopment]: "http://localhost:8000"
};
function serverURLFromOptions(options) {
    var _a;
    let serverURL = options.serverURL;
    const params = {};
    if (!serverURL) {
        const server = (_a = options.server) !== null && _a !== void 0 ? _a : exports.ServerSaasApi;
        serverURL = exports.ServerList[server] || "";
    }
    const u = (0, url_js_1.pathToFunc)(serverURL)(params);
    return new URL(u);
}
exports.serverURLFromOptions = serverURLFromOptions;
exports.SDK_METADATA = {
    language: "typescript",
    openapiDocVersion: "1.0.51",
    sdkVersion: "0.18.2",
    genVersion: "2.438.15",
    userAgent: "speakeasy-sdk/typescript 0.18.2 2.438.15 1.0.51 unstructured-client"
}; //# sourceMappingURL=config.js.map
}}),
"[project]/node_modules/unstructured-client/lib/files.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readableStreamToArrayBuffer = void 0;
/**
 * Consumes a stream and returns a concatenated array buffer. Useful in
 * situations where we need to read the whole file because it forms part of a
 * larger payload containing other fields, and we can't modify the underlying
 * request structure.
 */ async function readableStreamToArrayBuffer(readable) {
    const reader = readable.getReader();
    const chunks = [];
    let totalLength = 0;
    let done = false;
    while(!done){
        const { value, done: doneReading } = await reader.read();
        if (doneReading) {
            done = true;
        } else {
            chunks.push(value);
            totalLength += value.length;
        }
    }
    const concatenatedChunks = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks){
        concatenatedChunks.set(chunk, offset);
        offset += chunk.length;
    }
    return concatenatedChunks.buffer;
}
exports.readableStreamToArrayBuffer = readableStreamToArrayBuffer; //# sourceMappingURL=files.js.map
}}),
"[project]/node_modules/unstructured-client/hooks/custom/LoggerHook.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LoggerHook = void 0;
/**
 * Represents a hook that logs status and information that the request will be retried
 * after encountering a 5xx error.
 */ class LoggerHook {
    constructor(){
        this.retriesCounter = new Map();
    }
    /**
     * Log retries to give users visibility into requests.
     * @param response - The response object received from the server.
     * @param error - The error object representing the encountered error.
     * @param operationID - The unique identifier for the operation being logged.
     */ logRetries(response, error, operationID) {
        if (response && response.status >= 500) {
            console.warn("Failed to process a request due to API server error with status code %d. " + "Attempting retry number %d after sleep.", response.status, this.retriesCounter.get(operationID));
            if (response.statusText) {
                console.warn("Server message - %s", response.statusText);
            }
        } else if (error) {
            console.info(`Failed to process a request due to connection error - ${error.message}. ` + `Attempting retry number ${this.retriesCounter.get(operationID)} after sleep.`);
        }
    }
    /**
     * Handles successful responses, resetting the retry counter for the operation.
     * Logs a success message indicating that the document was successfully partitioned.
     * @param hookCtx - The context object containing information about the request.
     * @param response - The response object received from the server.
     * @returns The response object.
     */ afterSuccess(hookCtx, response) {
        this.retriesCounter.delete(hookCtx.operationID);
        // NOTE: In case of split page partition this means - at least one of the splits was partitioned successfully
        return response;
    }
    /**
     * Executes after an error occurs during a request.
     * @param hookCtx - The context object containing information about the request.
     * @param response - The response object received from the server.
     * @param error - The error object representing the encountered error.
     * @returns An object containing the updated response and error.
     */ afterError(hookCtx, response, error) {
        const currentCount = this.retriesCounter.get(hookCtx.operationID) || 0;
        this.retriesCounter.set(hookCtx.operationID, currentCount + 1);
        this.logRetries(response, error, hookCtx.operationID);
        if (response && response.status === 200) {
            return {
                response,
                error
            };
        }
        console.error("Failed to partition the document.");
        if (response) {
            console.error(`Server responded with ${response.status} - ${response.statusText}`);
        }
        if (error) {
            console.error(`Following error occurred - ${error.message}`);
        }
        return {
            response,
            error
        };
    }
}
exports.LoggerHook = LoggerHook; //# sourceMappingURL=LoggerHook.js.map
}}),
"[project]/node_modules/unstructured-client/lib/http.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAbortError = exports.isTimeoutError = exports.isConnectionError = exports.matchResponse = exports.matchStatusCode = exports.matchContentType = exports.HTTPClient = void 0;
const DEFAULT_FETCHER = (input, init)=>{
    // If input is a Request and init is undefined, Bun will discard the method,
    // headers, body and other options that were set on the request object.
    // Node.js and browers would ignore an undefined init value. This check is
    // therefore needed for interop with Bun.
    if (init == null) {
        return fetch(input);
    } else {
        return fetch(input, init);
    }
};
class HTTPClient {
    constructor(options = {}){
        this.options = options;
        this.requestHooks = [];
        this.requestErrorHooks = [];
        this.responseHooks = [];
        this.fetcher = options.fetcher || DEFAULT_FETCHER;
    }
    async request(request) {
        let req = request;
        for (const hook of this.requestHooks){
            const nextRequest = await hook(req);
            if (nextRequest) {
                req = nextRequest;
            }
        }
        try {
            const res = await this.fetcher(req);
            for (const hook of this.responseHooks){
                await hook(res, req);
            }
            return res;
        } catch (err) {
            for (const hook of this.requestErrorHooks){
                await hook(err, req);
            }
            throw err;
        }
    }
    addHook(...args) {
        if (args[0] === "beforeRequest") {
            this.requestHooks.push(args[1]);
        } else if (args[0] === "requestError") {
            this.requestErrorHooks.push(args[1]);
        } else if (args[0] === "response") {
            this.responseHooks.push(args[1]);
        } else {
            throw new Error(`Invalid hook type: ${args[0]}`);
        }
        return this;
    }
    removeHook(...args) {
        let target;
        if (args[0] === "beforeRequest") {
            target = this.requestHooks;
        } else if (args[0] === "requestError") {
            target = this.requestErrorHooks;
        } else if (args[0] === "response") {
            target = this.responseHooks;
        } else {
            throw new Error(`Invalid hook type: ${args[0]}`);
        }
        const index = target.findIndex((v)=>v === args[1]);
        if (index >= 0) {
            target.splice(index, 1);
        }
        return this;
    }
    clone() {
        const child = new HTTPClient(this.options);
        child.requestHooks = this.requestHooks.slice();
        child.requestErrorHooks = this.requestErrorHooks.slice();
        child.responseHooks = this.responseHooks.slice();
        return child;
    }
}
exports.HTTPClient = HTTPClient;
// A semicolon surrounded by optional whitespace characters is used to separate
// segments in a media type string.
const mediaParamSeparator = /\s*;\s*/g;
function matchContentType(response, pattern) {
    var _a;
    // `*` is a special case which means anything is acceptable.
    if (pattern === "*") {
        return true;
    }
    let contentType = ((_a = response.headers.get("content-type")) === null || _a === void 0 ? void 0 : _a.trim()) || "application/octet-stream";
    contentType = contentType.toLowerCase();
    const wantParts = pattern.toLowerCase().trim().split(mediaParamSeparator);
    const [wantType = "", ...wantParams] = wantParts;
    if (wantType.split("/").length !== 2) {
        return false;
    }
    const gotParts = contentType.split(mediaParamSeparator);
    const [gotType = "", ...gotParams] = gotParts;
    const [type = "", subtype = ""] = gotType.split("/");
    if (!type || !subtype) {
        return false;
    }
    if (wantType !== "*/*" && gotType !== wantType && `${type}/*` !== wantType && `*/${subtype}` !== wantType) {
        return false;
    }
    if (gotParams.length < wantParams.length) {
        return false;
    }
    const params = new Set(gotParams);
    for (const wantParam of wantParams){
        if (!params.has(wantParam)) {
            return false;
        }
    }
    return true;
}
exports.matchContentType = matchContentType;
const codeRangeRE = new RegExp("^[0-9]xx$", "i");
function matchStatusCode(response, codes) {
    const actual = `${response.status}`;
    const expectedCodes = Array.isArray(codes) ? codes : [
        codes
    ];
    if (!expectedCodes.length) {
        return false;
    }
    return expectedCodes.some((ec)=>{
        const code = `${ec}`;
        if (code === "default") {
            return true;
        }
        if (!codeRangeRE.test(`${code}`)) {
            return code === actual;
        }
        const expectFamily = code.charAt(0);
        if (!expectFamily) {
            throw new Error("Invalid status code range");
        }
        const actualFamily = actual.charAt(0);
        if (!actualFamily) {
            throw new Error(`Invalid response status code: ${actual}`);
        }
        return actualFamily === expectFamily;
    });
}
exports.matchStatusCode = matchStatusCode;
function matchResponse(response, code, contentTypePattern) {
    return matchStatusCode(response, code) && matchContentType(response, contentTypePattern);
}
exports.matchResponse = matchResponse;
/**
 * Uses various heurisitics to determine if an error is a connection error.
 */ function isConnectionError(err) {
    if (typeof err !== "object" || err == null) {
        return false;
    }
    // Covers fetch in Deno as well
    const isBrowserErr = err instanceof TypeError && err.message.toLowerCase().startsWith("failed to fetch");
    const isNodeErr = err instanceof TypeError && err.message.toLowerCase().startsWith("fetch failed");
    const isBunErr = "name" in err && err.name === "ConnectionError";
    const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnreset";
    return isBrowserErr || isNodeErr || isGenericErr || isBunErr;
}
exports.isConnectionError = isConnectionError;
/**
 * Uses various heurisitics to determine if an error is a timeout error.
 */ function isTimeoutError(err) {
    if (typeof err !== "object" || err == null) {
        return false;
    }
    // Fetch in browser, Node.js, Bun, Deno
    const isNative = "name" in err && err.name === "TimeoutError";
    const isLegacyNative = "code" in err && err.code === 23;
    // Node.js HTTP client and Axios
    const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
    return isNative || isLegacyNative || isGenericErr;
}
exports.isTimeoutError = isTimeoutError;
/**
 * Uses various heurisitics to determine if an error is a abort error.
 */ function isAbortError(err) {
    if (typeof err !== "object" || err == null) {
        return false;
    }
    // Fetch in browser, Node.js, Bun, Deno
    const isNative = "name" in err && err.name === "AbortError";
    const isLegacyNative = "code" in err && err.code === 20;
    // Node.js HTTP client and Axios
    const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
    return isNative || isLegacyNative || isGenericErr;
}
exports.isAbortError = isAbortError; //# sourceMappingURL=http.js.map
}}),
"[project]/node_modules/unstructured-client/hooks/custom/common.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HTTPClientExtension = exports.MAX_PAGES_PER_THREAD = exports.MIN_PAGES_PER_THREAD = exports.MAX_NUMBER_OF_PARALLEL_REQUESTS = exports.DEFAULT_SPLIT_PDF_ALLOW_FAILED_KEY = exports.DEFAULT_NUMBER_OF_PARALLEL_REQUESTS = exports.DEFAULT_STARTING_PAGE_NUMBER = exports.EXTRACT_IMAGE_BLOCK_TYPES = exports.PARTITION_FORM_SPLIT_PDF_CONCURRENCY_LEVEL = exports.PARTITION_FORM_SPLIT_PDF_PAGE_RANGE_KEY = exports.PARTITION_FORM_STARTING_PAGE_NUMBER_KEY = exports.PARTITION_FORM_SPLIT_PDF_ALLOW_FAILED_KEY = exports.PARTITION_FORM_SPLIT_PDF_PAGE_KEY = exports.PARTITION_FORM_FILES_KEY = exports.BASE_PROTOCOL = exports.BASE_HOSTNAME_REGEX = void 0;
const http_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/http.js [app-rsc] (ecmascript)");
/**
 * Regular expression pattern for matching base hostnames in the form of "*.unstructuredapp.io".
 */ exports.BASE_HOSTNAME_REGEX = /^.*\.unstructuredapp\.io$/;
/**
 * The base protocol used for HTTPS requests.
 */ exports.BASE_PROTOCOL = "https:";
exports.PARTITION_FORM_FILES_KEY = "files";
exports.PARTITION_FORM_SPLIT_PDF_PAGE_KEY = "split_pdf_page";
exports.PARTITION_FORM_SPLIT_PDF_ALLOW_FAILED_KEY = "split_pdf_allow_failed";
exports.PARTITION_FORM_STARTING_PAGE_NUMBER_KEY = "starting_page_number";
exports.PARTITION_FORM_SPLIT_PDF_PAGE_RANGE_KEY = "split_pdf_page_range";
exports.PARTITION_FORM_SPLIT_PDF_CONCURRENCY_LEVEL = "split_pdf_concurrency_level";
exports.EXTRACT_IMAGE_BLOCK_TYPES = "extract_image_block_types";
exports.DEFAULT_STARTING_PAGE_NUMBER = 1;
exports.DEFAULT_NUMBER_OF_PARALLEL_REQUESTS = 8;
exports.DEFAULT_SPLIT_PDF_ALLOW_FAILED_KEY = false;
exports.MAX_NUMBER_OF_PARALLEL_REQUESTS = 15;
exports.MIN_PAGES_PER_THREAD = 2;
exports.MAX_PAGES_PER_THREAD = 20;
class HTTPClientExtension extends http_1.HTTPClient {
    constructor(){
        super();
    }
    async request(request) {
        if (request.url === "https://no-op/") {
            return new Response('{}', {
                headers: [
                    [
                        "fake-response",
                        "fake-response"
                    ]
                ],
                status: 200,
                statusText: 'OK_NO_OP'
            });
        }
        return super.request(request);
    }
}
exports.HTTPClientExtension = HTTPClientExtension; //# sourceMappingURL=common.js.map
}}),
"[project]/node_modules/unstructured-client/hooks/custom/utils/form.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getStartingPageNumber = exports.getSplitPdfAllowFailed = exports.getSplitPdfConcurrencyLevel = exports.getSplitPdfPageRange = void 0;
const common_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/hooks/custom/common.js [app-rsc] (ecmascript)");
/**
 * Retrieves an integer parameter from the given form data.
 * If the parameter is not found or is not a valid integer, the default value is returned.
 *
 * @param formData - The form data object.
 * @param parameterName - The name of the parameter to retrieve.
 * @param defaultValue - The default value to use if the parameter is not found or is not
 * a valid integer.
 * @returns The integer value of the parameter.
 */ function getIntegerParameter(formData, parameterName, defaultValue) {
    let numberParameter = defaultValue;
    const formDataParameter = formData.get(parameterName);
    if (formDataParameter === null) {
        return numberParameter;
    }
    const formDataNumberParameter = parseInt(formDataParameter);
    if (isNaN(formDataNumberParameter)) {
        console.warn(`'${parameterName}' is not a valid integer. Using default value '${defaultValue}'.`);
    } else {
        numberParameter = formDataNumberParameter;
    }
    return numberParameter;
}
/**
 * Retrieves a boolean parameter from the given form data.
 * If the parameter is not found or does not have true/false value, the default value is returned.
 *
 * @param formData - The form data object.
 * @param parameterName - The name of the parameter to retrieve.
 * @param defaultValue - The default value to use if the parameter is not found or is not
 * a true/false string.
 * @returns The boolean value of the parameter.
 */ function getBooleanParameter(formData, parameterName, defaultValue) {
    let booleanParameter = defaultValue;
    const formDataParameter = formData.get(parameterName);
    if (formDataParameter === null) {
        return booleanParameter;
    }
    const formDataBooleanParameterString = formDataParameter;
    if (formDataBooleanParameterString.toLowerCase() === "true") {
        booleanParameter = true;
    } else if (formDataBooleanParameterString.toLowerCase() === "false") {
        booleanParameter = false;
    } else {
        console.warn(`'${parameterName}' is not a valid boolean. Using default value '${defaultValue}'.`);
    }
    return booleanParameter;
}
/**
 * Retrieves and validates a page range from FormData, ensuring that the start and end values are defined and within bounds.
 *
 * @param formData - The FormData object containing the page range parameter.
 * @param maxPages - The maximum number of pages in the document.
 * @returns {[number, number]} - A tuple containing the validated start and end page numbers.
 *
 * @throws Will throw an error if the page range is invalid or out of bounds.
 */ function getSplitPdfPageRange(formData, maxPages) {
    const formDataParameter = formData.get(common_js_1.PARTITION_FORM_SPLIT_PDF_PAGE_RANGE_KEY);
    const pageRange = String(formDataParameter).split(",").map(Number);
    const start = pageRange[0] || 1;
    const end = pageRange[1] || maxPages;
    if (!(start > 0 && start <= maxPages) || !(end > 0 && end <= maxPages) || !(start <= end)) {
        const msg = `Page range (${start} to ${end}) is out of bounds. Values should be between 1 and ${maxPages}.`;
        console.error(msg);
        throw new Error(msg);
    }
    return [
        start,
        end
    ];
}
exports.getSplitPdfPageRange = getSplitPdfPageRange;
/**
 * Gets the number of maximum requests that can be made when splitting PDF.
 * - The number of maximum requests is determined by the value of the request parameter
 * `split_pdf_thread`.
 * - If the parameter is not set or has an invalid value, the default number of
 * parallel requests (5) is used.
 * - If the number of maximum requests is greater than the maximum allowed (15), it is
 * clipped to the maximum value.
 * - If the number of maximum requests is less than 1, the default number of parallel
 * requests (5) is used.
 *
 * @returns The number of maximum requests to use when calling the API to split a PDF.
 */ function getSplitPdfConcurrencyLevel(formData) {
    let splitPdfConcurrencyLevel = getIntegerParameter(formData, common_js_1.PARTITION_FORM_SPLIT_PDF_CONCURRENCY_LEVEL, common_js_1.DEFAULT_NUMBER_OF_PARALLEL_REQUESTS);
    if (splitPdfConcurrencyLevel > common_js_1.MAX_NUMBER_OF_PARALLEL_REQUESTS) {
        console.warn(`Clipping '${common_js_1.PARTITION_FORM_SPLIT_PDF_CONCURRENCY_LEVEL}' to ${common_js_1.MAX_NUMBER_OF_PARALLEL_REQUESTS}.`);
        splitPdfConcurrencyLevel = common_js_1.MAX_NUMBER_OF_PARALLEL_REQUESTS;
    } else if (splitPdfConcurrencyLevel < 1) {
        console.warn(`'${common_js_1.PARTITION_FORM_SPLIT_PDF_CONCURRENCY_LEVEL}' is less than 1.`);
        splitPdfConcurrencyLevel = common_js_1.DEFAULT_NUMBER_OF_PARALLEL_REQUESTS;
    }
    return splitPdfConcurrencyLevel;
}
exports.getSplitPdfConcurrencyLevel = getSplitPdfConcurrencyLevel;
/**
 * Gets the allowFailed parameter which decides whether the partial requests can fail or not
 * when using splitPdfPage parameter.
 * - The number of maximum requests is determined by the value of the request parameter
 * `split_pdf_thread`.
 * - If the parameter is not set or has an invalid value, the default number of
 * parallel requests (5) is used.
 * - If the number of maximum requests is greater than the maximum allowed (15), it is
 * clipped to the maximum value.
 * - If the number of maximum requests is less than 1, the default number of parallel
 * requests (5) is used.
 *
 * @returns The number of maximum requests to use when calling the API to split a PDF.
 */ function getSplitPdfAllowFailed(formData) {
    const splitPdfAllowFailed = getBooleanParameter(formData, common_js_1.PARTITION_FORM_SPLIT_PDF_ALLOW_FAILED_KEY, common_js_1.DEFAULT_SPLIT_PDF_ALLOW_FAILED_KEY);
    return splitPdfAllowFailed;
}
exports.getSplitPdfAllowFailed = getSplitPdfAllowFailed;
/**
 * Retrieves the starting page number from the provided form data.
 * If the starting page number is not a valid integer or less than 1,
 * it will use the default value `1`.
 *
 * @param formData - Request form data.
 * @returns The starting page number.
 */ function getStartingPageNumber(formData) {
    let startingPageNumber = getIntegerParameter(formData, common_js_1.PARTITION_FORM_STARTING_PAGE_NUMBER_KEY, common_js_1.DEFAULT_STARTING_PAGE_NUMBER);
    if (startingPageNumber < 1) {
        console.warn(`'${common_js_1.PARTITION_FORM_STARTING_PAGE_NUMBER_KEY}' is less than 1. Using default value '${common_js_1.DEFAULT_STARTING_PAGE_NUMBER}'.`);
        startingPageNumber = common_js_1.DEFAULT_STARTING_PAGE_NUMBER;
    }
    return startingPageNumber;
}
exports.getStartingPageNumber = getStartingPageNumber; //# sourceMappingURL=form.js.map
}}),
"[project]/node_modules/unstructured-client/hooks/custom/utils/general.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stringToBoolean = void 0;
function stringToBoolean(string) {
    return string.toLocaleLowerCase() === "true";
}
exports.stringToBoolean = stringToBoolean; //# sourceMappingURL=general.js.map
}}),
"[project]/node_modules/unstructured-client/hooks/custom/utils/pdf.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loadPdf = exports.splitPdf = exports.getOptimalSplitSize = exports.pdfPagesToBlob = void 0;
const pdf_lib_1 = __turbopack_require__("[project]/node_modules/pdf-lib/es/index.js [app-rsc] (ecmascript)");
const common_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/hooks/custom/common.js [app-rsc] (ecmascript)");
/**
 * Converts range of pages (including start and end page values) of a PDF document
 * to a Blob object.
 * @param pdf - The PDF document.
 * @param startPage - Number of the first page of split.
 * @param endPage - Number of the last page of split.
 * @returns A Promise that resolves to a Blob object representing the converted pages.
 */ async function pdfPagesToBlob(pdf, startPage, endPage) {
    const subPdf = await pdf_lib_1.PDFDocument.create();
    // Create an array with page indices to copy
    // Converts 1-based page numbers to 0-based page indices
    const pageIndices = Array.from({
        length: endPage - startPage + 1
    }, (_, index)=>startPage + index - 1);
    const pages = await subPdf.copyPages(pdf, pageIndices);
    for (const page of pages){
        subPdf.addPage(page);
    }
    const subPdfBytes = await subPdf.save();
    return new Blob([
        subPdfBytes
    ], {
        type: "application/pdf"
    });
}
exports.pdfPagesToBlob = pdfPagesToBlob;
/**
 * Calculates the optimal split size for processing pages with a specified concurrency level.
 *
 * @param pagesCount - The total number of pages to process.
 * @param concurrencyLevel - The level of concurrency to be used.
 * @returns A promise that resolves to the optimal number of pages per split,
 * ensuring it does not exceed the maximum or fall below the minimum threshold.
 */ async function getOptimalSplitSize(pagesCount, concurrencyLevel) {
    let splitSize = common_js_1.MAX_PAGES_PER_THREAD;
    if (pagesCount < common_js_1.MAX_PAGES_PER_THREAD * concurrencyLevel) {
        splitSize = Math.ceil(pagesCount / concurrencyLevel);
    }
    splitSize = Math.max(splitSize, common_js_1.MIN_PAGES_PER_THREAD);
    return splitSize;
}
exports.getOptimalSplitSize = getOptimalSplitSize;
/**
 * Retrieves an array of splits, with the start and end page numbers, from a PDF file.
 * Distribution of pages per split is made in as much uniform manner as possible.
 *
 * @param pdf - The PDF file to extract pages from.
 * @param splitSize - The number of pages per split.
 * @param [pageRangeStart=1] - The starting page of the range to be split (1-based index). Defaults to the first page of the document.
 * @param [pageRangeEnd=pdf.getPageCount()] - The ending page of the range to be split (1-based index). Defaults to the last page of the document.
 * @returns A promise that resolves to an array of objects containing Blob files and
 * start and end page numbers from the original document.
 */ async function splitPdf(pdf, splitSize, pageRangeStart, pageRangeEnd) {
    const pdfSplits = [];
    const startPage = pageRangeStart || 1;
    const endPage = pageRangeEnd || pdf.getPageCount();
    const pagesCount = endPage - startPage + 1;
    const numberOfSplits = Math.ceil(pagesCount / splitSize);
    for(let i = 0; i < numberOfSplits; ++i){
        const offset = i * splitSize;
        const splitStartPage = offset + startPage;
        const splitEndPage = Math.min(endPage, splitStartPage + splitSize - 1);
        const pdfSplit = await pdfPagesToBlob(pdf, splitStartPage, splitEndPage);
        pdfSplits.push({
            content: pdfSplit,
            startPage: splitStartPage,
            endPage: splitEndPage
        });
    }
    return pdfSplits;
}
exports.splitPdf = splitPdf;
/**
 * Checks if the given file is a PDF by loading the file as a PDF using the `PDFDocument.load` method.
 * @param file - The file to check.
 * @returns A promise that resolves to three values, first is a boolean representing
 * whether there was an error during PDF load, second is a PDFDocument object or null
 * (depending if there was an error), and the third is the number of pages in the PDF.
 * The number of pages is 0 if there was an error while loading the file.
 */ async function loadPdf(file) {
    if (!file) {
        return [
            true,
            null,
            0
        ];
    }
    try {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdf_lib_1.PDFDocument.load(arrayBuffer);
        const pagesCount = pdf.getPages().length;
        return [
            false,
            pdf,
            pagesCount
        ];
    } catch (e) {
        return [
            true,
            null,
            0
        ];
    }
}
exports.loadPdf = loadPdf; //# sourceMappingURL=pdf.js.map
}}),
"[project]/node_modules/unstructured-client/hooks/custom/utils/request.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.prepareRequestBody = exports.prepareRequestHeaders = exports.prepareResponseBody = exports.prepareResponseHeaders = void 0;
const common_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/hooks/custom/common.js [app-rsc] (ecmascript)");
/**
 * Removes the "content-length" header from the passed response headers.
 *
 * @param response - The response object.
 * @returns The modified headers object.
 */ function prepareResponseHeaders(response) {
    const headers = new Headers(response.headers);
    headers.delete("content-length");
    return headers;
}
exports.prepareResponseHeaders = prepareResponseHeaders;
/**
 * Prepares the response body by extracting and flattening the JSON elements from
 * an array of responses.
 *
 * @param responses - An array of Response objects.
 * @returns A Promise that resolves to a string representation of the flattened
 * JSON elements.
 */ async function prepareResponseBody(responses) {
    const allElements = [];
    let index = 1;
    for (const res of responses){
        if (res.status != 200) {
            console.warn("Failed to partition set #%d, its elements will be omitted in the final result.", index);
        }
        const resElements = await res.json();
        allElements.push(resElements);
        index++;
    }
    return JSON.stringify(allElements.flat());
}
exports.prepareResponseBody = prepareResponseBody;
/**
 * Removes the "content-type" header from the given request headers.
 *
 * @param request - The request object containing the headers.
 * @returns The modified headers object.
 */ function prepareRequestHeaders(request) {
    const headers = new Headers(request.headers);
    headers.delete("content-type");
    return headers;
}
exports.prepareRequestHeaders = prepareRequestHeaders;
/**
 * Prepares the request body for splitting a PDF.
 *
 * @param formData - The original form data.
 * @param fileContent - The content of the pages to be split.
 * @param fileName - The name of the file.
 * @param startingPageNumber - Real first page number of the split.
 * @returns A Promise that resolves to a FormData object representing
 * the prepared request body.
 */ async function prepareRequestBody(formData, fileContent, fileName, startingPageNumber) {
    var _a;
    const newFormData = new FormData();
    for (const [key, value] of formData.entries()){
        if (![
            common_js_1.PARTITION_FORM_STARTING_PAGE_NUMBER_KEY,
            common_js_1.PARTITION_FORM_SPLIT_PDF_PAGE_KEY,
            common_js_1.PARTITION_FORM_FILES_KEY
        ].includes(key)) {
            newFormData.append(key, value);
        }
    }
    newFormData.append(common_js_1.PARTITION_FORM_SPLIT_PDF_PAGE_KEY, "false");
    newFormData.append(common_js_1.PARTITION_FORM_FILES_KEY, fileContent, fileName);
    newFormData.append(common_js_1.PARTITION_FORM_STARTING_PAGE_NUMBER_KEY, startingPageNumber.toString());
    if (formData.has(common_js_1.EXTRACT_IMAGE_BLOCK_TYPES)) {
        newFormData.delete(common_js_1.EXTRACT_IMAGE_BLOCK_TYPES);
        const extractImageBlockTypes = (((_a = formData.get(common_js_1.EXTRACT_IMAGE_BLOCK_TYPES)) === null || _a === void 0 ? void 0 : _a.toString()) || "").split(",");
        for (const blockType of extractImageBlockTypes){
            newFormData.append(common_js_1.EXTRACT_IMAGE_BLOCK_TYPES, blockType);
        }
    }
    return newFormData;
}
exports.prepareRequestBody = prepareRequestBody; //# sourceMappingURL=request.js.map
}}),
"[project]/node_modules/unstructured-client/hooks/custom/utils/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/hooks/custom/utils/form.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/hooks/custom/utils/general.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/hooks/custom/utils/pdf.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/hooks/custom/utils/request.js [app-rsc] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/unstructured-client/lib/retries.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.retry = void 0;
const http_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/http.js [app-rsc] (ecmascript)");
const defaultBackoff = {
    initialInterval: 500,
    maxInterval: 60000,
    exponent: 1.5,
    maxElapsedTime: 3600000
};
class PermanentError extends Error {
    constructor(inner){
        super("Permanent error");
        this.inner = inner;
        Object.setPrototypeOf(this, PermanentError.prototype);
    }
}
class TemporaryError extends Error {
    constructor(res){
        super("Temporary error");
        this.res = res;
        Object.setPrototypeOf(this, TemporaryError.prototype);
    }
}
async function retry(fetchFn, options) {
    var _a;
    switch(options.config.strategy){
        case "backoff":
            return retryBackoff(wrapFetcher(fetchFn, {
                statusCodes: options.statusCodes,
                retryConnectionErrors: !!options.config.retryConnectionErrors
            }), (_a = options.config.backoff) !== null && _a !== void 0 ? _a : defaultBackoff);
        default:
            return await fetchFn();
    }
}
exports.retry = retry;
function wrapFetcher(fn, options) {
    return async ()=>{
        try {
            const res = await fn();
            if (isRetryableResponse(res, options.statusCodes)) {
                throw new TemporaryError(res);
            }
            return res;
        } catch (err) {
            if (err instanceof TemporaryError) {
                throw err;
            }
            if (options.retryConnectionErrors && ((0, http_js_1.isTimeoutError)(err) || (0, http_js_1.isConnectionError)(err))) {
                throw err;
            }
            throw new PermanentError(err);
        }
    };
}
const codeRangeRE = new RegExp("^[0-9]xx$", "i");
function isRetryableResponse(res, statusCodes) {
    const actual = `${res.status}`;
    return statusCodes.some((code)=>{
        if (!codeRangeRE.test(code)) {
            return code === actual;
        }
        const expectFamily = code.charAt(0);
        if (!expectFamily) {
            throw new Error("Invalid status code range");
        }
        const actualFamily = actual.charAt(0);
        if (!actualFamily) {
            throw new Error(`Invalid response status code: ${actual}`);
        }
        return actualFamily === expectFamily;
    });
}
async function retryBackoff(fn, strategy) {
    const { maxElapsedTime, initialInterval, exponent, maxInterval } = strategy;
    const start = Date.now();
    let x = 0;
    // eslint-disable-next-line no-constant-condition
    while(true){
        try {
            const res = await fn();
            return res;
        } catch (err) {
            if (err instanceof PermanentError) {
                throw err.inner;
            }
            const elapsed = Date.now() - start;
            if (elapsed > maxElapsedTime) {
                if (err instanceof TemporaryError) {
                    return err.res;
                }
                throw err;
            }
            let retryInterval = 0;
            if (err instanceof TemporaryError && err.res && err.res.headers) {
                const retryVal = err.res.headers.get("retry-after") || "";
                if (retryVal != "") {
                    const parsedNumber = Number(retryVal);
                    if (!isNaN(parsedNumber) && Number.isInteger(parsedNumber)) {
                        retryInterval = parsedNumber * 1000;
                    } else {
                        const parsedDate = Date.parse(retryVal);
                        if (!isNaN(parsedDate)) {
                            const deltaMS = parsedDate - Date.now();
                            retryInterval = deltaMS > 0 ? Math.ceil(deltaMS) : 0;
                        }
                    }
                }
            }
            if (retryInterval == 0) {
                retryInterval = initialInterval * Math.pow(x, exponent) + Math.random() * 1000;
            }
            const d = Math.min(retryInterval, maxInterval);
            await delay(d);
            x++;
        }
    }
}
async function delay(delay) {
    return new Promise((resolve)=>setTimeout(resolve, delay));
} //# sourceMappingURL=retries.js.map
}}),
"[project]/node_modules/unstructured-client/hooks/custom/SplitPdfHook.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SplitPdfHook = void 0;
const async_1 = __importDefault(__turbopack_require__("[project]/node_modules/async/dist/async.mjs [app-rsc] (ecmascript)"));
const crypto_1 = __turbopack_require__("[externals]/ [external] (crypto, cjs)");
const index_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/hooks/custom/utils/index.js [app-rsc] (ecmascript)");
const common_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/hooks/custom/common.js [app-rsc] (ecmascript)");
const retries_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/retries.js [app-rsc] (ecmascript)");
/**
 * Represents a hook for splitting and sending PDF files as per page requests.
 */ class SplitPdfHook {
    constructor(){
        /**
         * Maps lists responses to client operation.
         */ this.partitionSuccessfulResponses = {};
        /**
         * Maps lists failed responses to client operation.
         */ this.partitionFailedResponses = {};
        /**
         * Maps parallel requests to client operation.
         */ this.partitionRequests = {};
    }
    /**
     * Initializes Split PDF Hook.
     * @param opts - The options for SDK initialization.
     * @returns The initialized SDK options.
     */ sdkInit(opts) {
        const { baseURL } = opts;
        this.client = new common_js_1.HTTPClientExtension();
        this.client.addHook("response", (res)=>{
            if (res.status != 200) {
                console.error("Request failed with status code", `${res.status}`);
            }
        });
        return {
            baseURL: baseURL,
            client: this.client
        };
    }
    /**
     * If `splitPdfPage` is set to `true` in the request, the PDF file is split into
     * separate batches. Each batch is sent as a separate request in parallel. The last
     * batch request is returned by this method. It will return the original request
     * when: `splitPdfPage` is set to `false`, the file is not a PDF, or the HTTP
     * has not been initialized.
     *
     * @param hookCtx - The hook context containing information about the operation.
     * @param request - The request object.
     * @returns If `splitPdfPage` is set to `true`, the last batch request; otherwise,
     * the original request.
     */ async beforeRequest(hookCtx, request) {
        var _a;
        // setting the current operationID to be unique
        const operationID = "partition-" + (0, crypto_1.randomUUID)();
        hookCtx.operationID = operationID;
        const requestClone = request.clone();
        const formData = await requestClone.formData();
        const splitPdfPage = (0, index_js_1.stringToBoolean)((_a = formData.get(common_js_1.PARTITION_FORM_SPLIT_PDF_PAGE_KEY)) !== null && _a !== void 0 ? _a : "false");
        const file = formData.get(common_js_1.PARTITION_FORM_FILES_KEY);
        if (!splitPdfPage) {
            return request;
        }
        if (!this.client) {
            console.warn("HTTP client not accessible! Partitioning without split.");
            return request;
        }
        const [error, pdf, totalPages] = await (0, index_js_1.loadPdf)(file);
        if (file === null || pdf === null || error) {
            return request;
        }
        const [pageRangeStart, pageRangeEnd] = (0, index_js_1.getSplitPdfPageRange)(formData, totalPages);
        const pagesCount = pageRangeEnd - pageRangeStart + 1;
        const startingPageNumber = (0, index_js_1.getStartingPageNumber)(formData);
        const concurrencyLevel = (0, index_js_1.getSplitPdfConcurrencyLevel)(formData);
        this.allowFailed = (0, index_js_1.getSplitPdfAllowFailed)(formData);
        const splitSize = await (0, index_js_1.getOptimalSplitSize)(pagesCount, concurrencyLevel);
        // If user wants a specific page range, we need to call splitPdf,
        // even if this page count is too small to be split normally
        const isPageRangeRequested = pagesCount < totalPages;
        // Otherwise, if there are not enough pages, return the original request without splitting
        if (!isPageRangeRequested) {
            if (splitSize >= pagesCount || pagesCount < common_js_1.MIN_PAGES_PER_THREAD) {
                return request;
            }
        }
        const splits = await (0, index_js_1.splitPdf)(pdf, splitSize, pageRangeStart, pageRangeEnd);
        const oneSecond = 1000;
        const oneMinute = 1000 * 60;
        const sixtyMinutes = oneMinute * 60;
        const headers = (0, index_js_1.prepareRequestHeaders)(request);
        const requests = [];
        let setIndex = 1;
        for (const { content, startPage } of splits){
            // Both startPage and startingPageNumber are 1-based, so we need to subtract 1
            const firstPageNumber = startPage + startingPageNumber - 1;
            const body = await (0, index_js_1.prepareRequestBody)(formData, content, file.name, firstPageNumber);
            const req = new Request(requestClone, {
                headers,
                body,
                signal: AbortSignal.timeout(sixtyMinutes)
            });
            requests.push(req);
            setIndex += 1;
        }
        this.partitionSuccessfulResponses[operationID] = new Array(requests.length);
        this.partitionFailedResponses[operationID] = new Array(requests.length);
        const allowFailed = this.allowFailed;
        // These are the retry values from our api spec
        // We need to hardcode them here until we're able to reuse the SDK
        // from within this hook
        const allowedRetries = 3;
        const retryConfig = {
            strategy: "backoff",
            backoff: {
                initialInterval: oneSecond * 3,
                maxInterval: oneMinute * 12,
                exponent: 1.88,
                maxElapsedTime: sixtyMinutes
            }
        };
        const retryCodes = [
            "502",
            "503",
            "504"
        ];
        this.partitionRequests[operationID] = async_1.default.parallelLimit(requests.map((req, pageIndex)=>async ()=>{
                const pageNumber = pageIndex + startingPageNumber;
                let retryCount = 0;
                try {
                    const response = await (0, retries_1.retry)(async ()=>{
                        retryCount++;
                        if (retryCount > allowedRetries) {
                            throw new Error(`Number of retries exceeded for page ${pageNumber}`);
                        }
                        return await this.client.request(req.clone());
                    }, {
                        config: retryConfig,
                        statusCodes: retryCodes
                    });
                    if (response.status === 200) {
                        this.partitionSuccessfulResponses[operationID][pageIndex] = response.clone();
                    } else {
                        this.partitionFailedResponses[operationID][pageIndex] = response.clone();
                        if (!allowFailed) {
                            throw new Error(`Failed to send request for page ${pageNumber}.`);
                        }
                    }
                } catch (e) {
                    console.error(`Failed to send request for page ${pageNumber}.`, e);
                    if (!allowFailed) {
                        throw e;
                    }
                }
            }), concurrencyLevel);
        return new Request("https://no-op/");
    }
    /**
     * Forms the final response object based on the successful and failed responses.
     * @param response - The response object returned from the API request.
     *   Expected to be a successful response.
     * @param successfulResponses - The list of successful responses.
     * @param failedResponses - The list of failed responses.
     * @returns The final response object.
     */ async formFinalResponse(response, successfulResponses, failedResponses) {
        var _a, _b;
        let realResponse = response.clone();
        const firstSuccessfulResponse = successfulResponses.at(0);
        const isFakeResponse = response.headers.has("fake-response");
        if (firstSuccessfulResponse !== undefined && isFakeResponse) {
            realResponse = firstSuccessfulResponse.clone();
        }
        let responseBody, responseStatus, responseStatusText;
        const numFailedResponses = (_a = failedResponses === null || failedResponses === void 0 ? void 0 : failedResponses.length) !== null && _a !== void 0 ? _a : 0;
        const headers = (0, index_js_1.prepareResponseHeaders)(realResponse);
        if (!this.allowFailed && failedResponses && failedResponses.length > 0) {
            const failedResponse = (_b = failedResponses[0]) === null || _b === void 0 ? void 0 : _b.clone();
            if (failedResponse) {
                responseBody = await failedResponse.text();
                responseStatusText = failedResponse.statusText;
            } else {
                responseBody = JSON.stringify({
                    "details:": "Unknown error"
                });
                responseStatusText = "Unknown error";
            }
            // if the response status is unknown or was 502, 503, 504, set back to 500 to ensure we don't cause more retries
            responseStatus = 500;
            console.warn(`${numFailedResponses} requests failed. The partition operation is cancelled.`);
        } else {
            if (isFakeResponse) {
                responseBody = await (0, index_js_1.prepareResponseBody)([
                    ...successfulResponses
                ]);
            } else {
                responseBody = await (0, index_js_1.prepareResponseBody)([
                    ...successfulResponses,
                    response
                ]);
            }
            responseStatus = realResponse.status;
            responseStatusText = realResponse.statusText;
            if (numFailedResponses > 0) {
                console.warn(`${numFailedResponses} requests failed. The results might miss some pages.`);
            }
        }
        return new Response(responseBody, {
            headers: headers,
            status: responseStatus,
            statusText: responseStatusText
        });
    }
    /**
     * Executes after a successful API request. Awaits all parallel requests and combines
     * the responses into a single response object.
     * @param hookCtx - The context object containing information about the hook execution.
     * @param response - The response object returned from the API request.
     * @returns If requests were run in parallel, a combined response object; otherwise,
     * the original response.
     */ async afterSuccess(hookCtx, response) {
        var _a, _b;
        const { operationID } = hookCtx;
        const responses = await this.awaitAllRequests(operationID);
        const successfulResponses = (_a = responses === null || responses === void 0 ? void 0 : responses.get("success")) !== null && _a !== void 0 ? _a : [];
        const failedResponses = (_b = responses === null || responses === void 0 ? void 0 : responses.get("failed")) !== null && _b !== void 0 ? _b : [];
        if (!successfulResponses) {
            return response;
        }
        const finalResponse = await this.formFinalResponse(response, successfulResponses, failedResponses);
        this.clearOperation(operationID);
        return finalResponse;
    }
    /**
     * Executes after an unsuccessful API request. Awaits all parallel requests, if at least one
     * request was successful, combines the responses into a single response object and doesn't
     * throw an error. It will return an error only if all requests failed, or there was no PDF split.
     * @param hookCtx - The AfterErrorContext object containing information about the hook context.
     * @param response - The Response object representing the response received before the error occurred.
     * @param error - The error object that was thrown.
     * @returns If requests were run in parallel, and at least one was successful, a combined response
     * object; otherwise, the original response and error.
     */ async afterError(hookCtx, response, error) {
        var _a, _b;
        const { operationID } = hookCtx;
        const responses = await this.awaitAllRequests(operationID);
        const successfulResponses = (_a = responses === null || responses === void 0 ? void 0 : responses.get("success")) !== null && _a !== void 0 ? _a : [];
        const failedResponses = (_b = responses === null || responses === void 0 ? void 0 : responses.get("failed")) !== null && _b !== void 0 ? _b : [];
        if (!(successfulResponses === null || successfulResponses === void 0 ? void 0 : successfulResponses.length)) {
            this.clearOperation(operationID);
            return {
                response,
                error
            };
        }
        const okResponse = successfulResponses[0];
        const finalResponse = await this.formFinalResponse(okResponse, successfulResponses.slice(1), failedResponses);
        this.clearOperation(operationID);
        return {
            response: finalResponse,
            error: null
        };
    }
    /**
     * Clears the parallel requests and response data associated with the given
     * operation ID.
     *
     * @param operationID - The ID of the operation to clear.
     */ clearOperation(operationID) {
        delete this.partitionSuccessfulResponses[operationID];
        delete this.partitionFailedResponses[operationID];
        delete this.partitionRequests[operationID];
    }
    /**
     * Awaits all parallel requests for a given operation ID and returns the
     * responses.
     * @param operationID - The ID of the operation.
     * @returns A promise that resolves to an array of responses, or undefined
     * if there are no requests for the given operation ID.
     */ async awaitAllRequests(operationID) {
        var _a, _b, _c, _d;
        const requests = this.partitionRequests[operationID];
        const responseMap = new Map();
        if (!requests) {
            return responseMap;
        }
        await requests;
        responseMap.set("success", (_b = (_a = this.partitionSuccessfulResponses[operationID]) === null || _a === void 0 ? void 0 : _a.filter((e)=>e)) !== null && _b !== void 0 ? _b : []);
        responseMap.set("failed", (_d = (_c = this.partitionFailedResponses[operationID]) === null || _c === void 0 ? void 0 : _c.filter((e)=>e)) !== null && _d !== void 0 ? _d : []);
        return responseMap;
    }
}
exports.SplitPdfHook = SplitPdfHook; //# sourceMappingURL=SplitPdfHook.js.map
}}),
"[project]/node_modules/unstructured-client/hooks/custom/HttpsCheckHook.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HttpsCheckHook = void 0;
const common_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/hooks/custom/common.js [app-rsc] (ecmascript)");
/**
 * Represents a hook that performs base host HTTPS check during SDK initialization.
 */ class HttpsCheckHook {
    /**
     * Performs the base host HTTPS check during SDK initialization. If hostname
     * matches "*.unstructuredapp.io" and the protocol is not "https:", the protocol
     * is updated to "https:".
     * @param opts - The SDK initialization options.
     * @returns The updated SDK initialization options.
     */ sdkInit(opts) {
        const { baseURL, client } = opts;
        if (baseURL) {
            // -- pathname should always be empty
            baseURL.pathname = "/";
            if (common_js_1.BASE_HOSTNAME_REGEX.test(baseURL.hostname) && baseURL.protocol !== common_js_1.BASE_PROTOCOL) {
                console.warn("Base URL protocol is not HTTPS. Updating to HTTPS.");
                const newBaseURL = baseURL.href.replace(baseURL.protocol, common_js_1.BASE_PROTOCOL);
                return {
                    baseURL: new URL(newBaseURL),
                    client: client
                };
            }
        }
        return {
            baseURL: baseURL,
            client: client
        };
    }
}
exports.HttpsCheckHook = HttpsCheckHook; //# sourceMappingURL=HttpsCheckHook.js.map
}}),
"[project]/node_modules/unstructured-client/hooks/registration.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.initHooks = void 0;
const LoggerHook_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/hooks/custom/LoggerHook.js [app-rsc] (ecmascript)");
const SplitPdfHook_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/hooks/custom/SplitPdfHook.js [app-rsc] (ecmascript)");
const HttpsCheckHook_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/hooks/custom/HttpsCheckHook.js [app-rsc] (ecmascript)");
/*
 * This file is only ever generated once on the first generation and then is free to be modified.
 * Any hooks you wish to add should be registered in the initHooks function. Feel free to define them
 * in this file or in separate files in the hooks folder.
 */ function initHooks(hooks) {
    // Add hooks by calling hooks.register{ClientInit/BeforeRequest/AfterSuccess/AfterError}Hook
    // with an instance of a hook that implements that specific Hook interface
    // Hooks are registered per SDK instance, and are valid for the lifetime of the SDK instance
    // Initialize hooks
    const loggerHook = new LoggerHook_js_1.LoggerHook();
    const splitPdfHook = new SplitPdfHook_js_1.SplitPdfHook();
    const httpsCheckHook = new HttpsCheckHook_js_1.HttpsCheckHook();
    // NOTE: logger_hook should stay registered last as logs the status of
    // request and whether it will be retried which can be changed by e.g. split_pdf_hook
    // Register SDK init hooks
    hooks.registerSDKInitHook(httpsCheckHook);
    hooks.registerSDKInitHook(splitPdfHook);
    // Register before request hooks
    hooks.registerBeforeRequestHook(splitPdfHook);
    // Register after success hooks
    hooks.registerAfterSuccessHook(splitPdfHook);
    hooks.registerAfterSuccessHook(loggerHook);
    // Register after error hooks
    hooks.registerAfterErrorHook(splitPdfHook);
    hooks.registerAfterErrorHook(loggerHook);
}
exports.initHooks = initHooks; //# sourceMappingURL=registration.js.map
}}),
"[project]/node_modules/unstructured-client/hooks/hooks.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SDKHooks = void 0;
const registration_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/hooks/registration.js [app-rsc] (ecmascript)");
class SDKHooks {
    constructor(){
        this.sdkInitHooks = [];
        this.beforeCreateRequestHooks = [];
        this.beforeRequestHooks = [];
        this.afterSuccessHooks = [];
        this.afterErrorHooks = [];
        (0, registration_js_1.initHooks)(this);
    }
    registerSDKInitHook(hook) {
        this.sdkInitHooks.push(hook);
    }
    registerBeforeCreateRequestHook(hook) {
        this.beforeCreateRequestHooks.push(hook);
    }
    registerBeforeRequestHook(hook) {
        this.beforeRequestHooks.push(hook);
    }
    registerAfterSuccessHook(hook) {
        this.afterSuccessHooks.push(hook);
    }
    registerAfterErrorHook(hook) {
        this.afterErrorHooks.push(hook);
    }
    sdkInit(opts) {
        return this.sdkInitHooks.reduce((opts, hook)=>hook.sdkInit(opts), opts);
    }
    beforeCreateRequest(hookCtx, input) {
        let inp = input;
        for (const hook of this.beforeCreateRequestHooks){
            inp = hook.beforeCreateRequest(hookCtx, inp);
        }
        return inp;
    }
    async beforeRequest(hookCtx, request) {
        let req = request;
        for (const hook of this.beforeRequestHooks){
            req = await hook.beforeRequest(hookCtx, req);
        }
        return req;
    }
    async afterSuccess(hookCtx, response) {
        let res = response;
        for (const hook of this.afterSuccessHooks){
            res = await hook.afterSuccess(hookCtx, res);
        }
        return res;
    }
    async afterError(hookCtx, response, error) {
        let res = response;
        let err = error;
        for (const hook of this.afterErrorHooks){
            const result = await hook.afterError(hookCtx, res, err);
            res = result.response;
            err = result.error;
        }
        return {
            response: res,
            error: err
        };
    }
}
exports.SDKHooks = SDKHooks; //# sourceMappingURL=hooks.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/models/errors/httpclienterrors.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionError = exports.RequestTimeoutError = exports.RequestAbortedError = exports.InvalidRequestError = exports.UnexpectedClientError = exports.HTTPClientError = void 0;
/**
 * Base class for all HTTP errors.
 */ class HTTPClientError extends Error {
    constructor(message, opts){
        let msg = message;
        if (opts === null || opts === void 0 ? void 0 : opts.cause) {
            msg += `: ${opts.cause}`;
        }
        super(msg, opts);
        this.name = "HTTPClientError";
        // In older runtimes, the cause field would not have been assigned through
        // the super() call.
        if (typeof this.cause === "undefined") {
            this.cause = opts === null || opts === void 0 ? void 0 : opts.cause;
        }
    }
}
exports.HTTPClientError = HTTPClientError;
/**
 * An error to capture unrecognised or unexpected errors when making HTTP calls.
 */ class UnexpectedClientError extends HTTPClientError {
    constructor(){
        super(...arguments);
        this.name = "UnexpectedClientError";
    }
}
exports.UnexpectedClientError = UnexpectedClientError;
/**
 * An error that is raised when any inputs used to create a request are invalid.
 */ class InvalidRequestError extends HTTPClientError {
    constructor(){
        super(...arguments);
        this.name = "InvalidRequestError";
    }
}
exports.InvalidRequestError = InvalidRequestError;
/**
 * An error that is raised when a HTTP request was aborted by the client error.
 */ class RequestAbortedError extends HTTPClientError {
    constructor(){
        super(...arguments);
        this.name = "RequestAbortedError";
    }
}
exports.RequestAbortedError = RequestAbortedError;
/**
 * An error that is raised when a HTTP request timed out due to an AbortSignal
 * signal timeout.
 */ class RequestTimeoutError extends HTTPClientError {
    constructor(){
        super(...arguments);
        this.name = "RequestTimeoutError";
    }
}
exports.RequestTimeoutError = RequestTimeoutError;
/**
 * An error that is raised when a HTTP client is unable to make a request to
 * a server.
 */ class ConnectionError extends HTTPClientError {
    constructor(){
        super(...arguments);
        this.name = "ConnectionError";
    }
}
exports.ConnectionError = ConnectionError; //# sourceMappingURL=httpclienterrors.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/types/fp.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unwrapAsync = exports.unwrap = exports.ERR = exports.OK = void 0;
function OK(value) {
    return {
        ok: true,
        value
    };
}
exports.OK = OK;
function ERR(error) {
    return {
        ok: false,
        error
    };
}
exports.ERR = ERR;
/**
 * unwrap is a convenience function for extracting a value from a result or
 * throwing if there was an error.
 */ function unwrap(r) {
    if (!r.ok) {
        throw r.error;
    }
    return r.value;
}
exports.unwrap = unwrap;
/**
 * unwrapAsync is a convenience function for resolving a value from a Promise
 * of a result or rejecting if an error occurred.
 */ async function unwrapAsync(pr) {
    const r = await pr;
    if (!r.ok) {
        throw r.error;
    }
    return r.value;
}
exports.unwrapAsync = unwrapAsync; //# sourceMappingURL=fp.js.map
}}),
"[project]/node_modules/unstructured-client/lib/base64.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.zodInbound = exports.zodOutbound = exports.stringFromBase64 = exports.stringToBase64 = exports.stringFromBytes = exports.stringToBytes = exports.bytesFromBase64 = exports.bytesToBase64 = void 0;
const z = __importStar(__turbopack_require__("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)"));
function bytesToBase64(u8arr) {
    return btoa(String.fromCodePoint(...u8arr));
}
exports.bytesToBase64 = bytesToBase64;
function bytesFromBase64(encoded) {
    return Uint8Array.from(atob(encoded), (c)=>c.charCodeAt(0));
}
exports.bytesFromBase64 = bytesFromBase64;
function stringToBytes(str) {
    return new TextEncoder().encode(str);
}
exports.stringToBytes = stringToBytes;
function stringFromBytes(u8arr) {
    return new TextDecoder().decode(u8arr);
}
exports.stringFromBytes = stringFromBytes;
function stringToBase64(str) {
    return bytesToBase64(stringToBytes(str));
}
exports.stringToBase64 = stringToBase64;
function stringFromBase64(b64str) {
    return stringFromBytes(bytesFromBase64(b64str));
}
exports.stringFromBase64 = stringFromBase64;
exports.zodOutbound = z.instanceof(Uint8Array).or(z.string().transform(stringToBytes));
exports.zodInbound = z.instanceof(Uint8Array).or(z.string().transform(bytesFromBase64)); //# sourceMappingURL=base64.js.map
}}),
"[project]/node_modules/unstructured-client/lib/is-plain-object.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isPlainObject = void 0;
/*
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/ // Taken from https://github.com/sindresorhus/is-plain-obj/blob/97f38e8836f86a642cce98fc6ab3058bc36df181/index.js
function isPlainObject(value) {
    if (typeof value !== "object" || value === null) {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
exports.isPlainObject = isPlainObject; //# sourceMappingURL=is-plain-object.js.map
}}),
"[project]/node_modules/unstructured-client/lib/encodings.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeDeepObjectQuery = exports.encodePipeDelimitedQuery = exports.encodeSpaceDelimitedQuery = exports.encodeFormQuery = exports.encodeJSONQuery = exports.queryEncoder = exports.queryJoin = exports.encodeSimple = exports.encodeJSON = exports.encodeDeepObjectObject = exports.encodeDeepObject = exports.encodeBodyForm = exports.encodePipeDelimited = exports.encodeSpaceDelimited = exports.encodeForm = exports.encodeLabel = exports.encodeMatrix = exports.EncodingError = void 0;
const base64_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/base64.js [app-rsc] (ecmascript)");
const is_plain_object_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/is-plain-object.js [app-rsc] (ecmascript)");
class EncodingError extends Error {
    constructor(message){
        super(message);
        this.name = "EncodingError";
    }
}
exports.EncodingError = EncodingError;
function encodeMatrix(key, value, options) {
    let out = "";
    const pairs = (options === null || options === void 0 ? void 0 : options.explode) ? explode(key, value) : [
        [
            key,
            value
        ]
    ];
    const encodeString = (v)=>{
        return (options === null || options === void 0 ? void 0 : options.charEncoding) === "percent" ? encodeURIComponent(v) : v;
    };
    const encodeValue = (v)=>encodeString(serializeValue(v));
    pairs.forEach(([pk, pv])=>{
        let tmp = "";
        let encValue = "";
        if (pv === undefined) {
            return;
        } else if (Array.isArray(pv)) {
            encValue = mapDefined(pv, (v)=>`${encodeValue(v)}`).join(",");
        } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
            encValue = mapDefinedEntries(Object.entries(pv), ([k, v])=>{
                return `,${encodeString(k)},${encodeValue(v)}`;
            }).join("");
            encValue = encValue.slice(1);
        } else {
            encValue = `${encodeValue(pv)}`;
        }
        const keyPrefix = encodeString(pk);
        tmp = `${keyPrefix}=${encValue}`;
        // trim trailing '=' if value was empty
        if (tmp === `${keyPrefix}=`) {
            tmp = tmp.slice(0, -1);
        }
        // If we end up with the nothing then skip forward
        if (!tmp) {
            return;
        }
        out += `;${tmp}`;
    });
    return out;
}
exports.encodeMatrix = encodeMatrix;
function encodeLabel(key, value, options) {
    let out = "";
    const pairs = (options === null || options === void 0 ? void 0 : options.explode) ? explode(key, value) : [
        [
            key,
            value
        ]
    ];
    const encodeString = (v)=>{
        return (options === null || options === void 0 ? void 0 : options.charEncoding) === "percent" ? encodeURIComponent(v) : v;
    };
    const encodeValue = (v)=>encodeString(serializeValue(v));
    pairs.forEach(([pk, pv])=>{
        let encValue = "";
        if (pv === undefined) {
            return;
        } else if (Array.isArray(pv)) {
            encValue = mapDefined(pv, (v)=>`${encodeValue(v)}`).join(".");
        } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
            encValue = mapDefinedEntries(Object.entries(pv), ([k, v])=>{
                return `.${encodeString(k)}.${encodeValue(v)}`;
            }).join("");
            encValue = encValue.slice(1);
        } else {
            const k = (options === null || options === void 0 ? void 0 : options.explode) && (0, is_plain_object_js_1.isPlainObject)(value) ? `${encodeString(pk)}=` : "";
            encValue = `${k}${encodeValue(pv)}`;
        }
        out += `.${encValue}`;
    });
    return out;
}
exports.encodeLabel = encodeLabel;
function formEncoder(sep) {
    return (key, value, options)=>{
        let out = "";
        const pairs = (options === null || options === void 0 ? void 0 : options.explode) ? explode(key, value) : [
            [
                key,
                value
            ]
        ];
        const encodeString = (v)=>{
            return (options === null || options === void 0 ? void 0 : options.charEncoding) === "percent" ? encodeURIComponent(v) : v;
        };
        const encodeValue = (v)=>encodeString(serializeValue(v));
        const encodedSep = encodeString(sep);
        pairs.forEach(([pk, pv])=>{
            let tmp = "";
            let encValue = "";
            if (pv === undefined) {
                return;
            } else if (Array.isArray(pv)) {
                encValue = mapDefined(pv, (v)=>`${encodeValue(v)}`).join(encodedSep);
            } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
                encValue = mapDefinedEntries(Object.entries(pv), ([k, v])=>{
                    return `${encodeString(k)}${encodedSep}${encodeValue(v)}`;
                }).join(encodedSep);
            } else {
                encValue = `${encodeValue(pv)}`;
            }
            tmp = `${encodeString(pk)}=${encValue}`;
            // If we end up with the nothing then skip forward
            if (!tmp || tmp === "=") {
                return;
            }
            out += `&${tmp}`;
        });
        return out.slice(1);
    };
}
exports.encodeForm = formEncoder(",");
exports.encodeSpaceDelimited = formEncoder(" ");
exports.encodePipeDelimited = formEncoder("|");
function encodeBodyForm(key, value, options) {
    let out = "";
    const pairs = (options === null || options === void 0 ? void 0 : options.explode) ? explode(key, value) : [
        [
            key,
            value
        ]
    ];
    const encodeString = (v)=>{
        return (options === null || options === void 0 ? void 0 : options.charEncoding) === "percent" ? encodeURIComponent(v) : v;
    };
    const encodeValue = (v)=>encodeString(serializeValue(v));
    pairs.forEach(([pk, pv])=>{
        let tmp = "";
        let encValue = "";
        if (pv === undefined) {
            return;
        } else if (Array.isArray(pv)) {
            encValue = JSON.stringify(pv, jsonReplacer);
        } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
            encValue = JSON.stringify(pv, jsonReplacer);
        } else {
            encValue = `${encodeValue(pv)}`;
        }
        tmp = `${encodeString(pk)}=${encValue}`;
        // If we end up with the nothing then skip forward
        if (!tmp || tmp === "=") {
            return;
        }
        out += `&${tmp}`;
    });
    return out.slice(1);
}
exports.encodeBodyForm = encodeBodyForm;
function encodeDeepObject(key, value, options) {
    if (value == null) {
        return "";
    }
    if (!(0, is_plain_object_js_1.isPlainObject)(value)) {
        throw new EncodingError(`Value of parameter '${key}' which uses deepObject encoding must be an object`);
    }
    return encodeDeepObjectObject(key, value, options);
}
exports.encodeDeepObject = encodeDeepObject;
function encodeDeepObjectObject(key, value, options) {
    if (value == null) {
        return "";
    }
    let out = "";
    const encodeString = (v)=>{
        return (options === null || options === void 0 ? void 0 : options.charEncoding) === "percent" ? encodeURIComponent(v) : v;
    };
    if (!(0, is_plain_object_js_1.isPlainObject)(value)) {
        throw new EncodingError(`Expected parameter '${key}' to be an object.`);
    }
    Object.entries(value).forEach(([ck, cv])=>{
        if (cv === undefined) {
            return;
        }
        const pk = `${key}[${ck}]`;
        if ((0, is_plain_object_js_1.isPlainObject)(cv)) {
            const objOut = encodeDeepObjectObject(pk, cv, options);
            out += `&${objOut}`;
            return;
        }
        const pairs = Array.isArray(cv) ? cv : [
            cv
        ];
        let encoded = "";
        encoded = mapDefined(pairs, (v)=>{
            return `${encodeString(pk)}=${encodeString(serializeValue(v))}`;
        }).join("&");
        out += `&${encoded}`;
    });
    return out.slice(1);
}
exports.encodeDeepObjectObject = encodeDeepObjectObject;
function encodeJSON(key, value, options) {
    if (typeof value === "undefined") {
        return "";
    }
    const encodeString = (v)=>{
        return (options === null || options === void 0 ? void 0 : options.charEncoding) === "percent" ? encodeURIComponent(v) : v;
    };
    const encVal = encodeString(JSON.stringify(value, jsonReplacer));
    return (options === null || options === void 0 ? void 0 : options.explode) ? encVal : `${encodeString(key)}=${encVal}`;
}
exports.encodeJSON = encodeJSON;
const encodeSimple = (key, value, options)=>{
    let out = "";
    const pairs = (options === null || options === void 0 ? void 0 : options.explode) ? explode(key, value) : [
        [
            key,
            value
        ]
    ];
    const encodeString = (v)=>{
        return (options === null || options === void 0 ? void 0 : options.charEncoding) === "percent" ? encodeURIComponent(v) : v;
    };
    const encodeValue = (v)=>encodeString(serializeValue(v));
    pairs.forEach(([pk, pv])=>{
        let tmp = "";
        if (pv === undefined) {
            return;
        } else if (Array.isArray(pv)) {
            tmp = mapDefined(pv, (v)=>`${encodeValue(v)}`).join(",");
        } else if ((0, is_plain_object_js_1.isPlainObject)(pv)) {
            tmp = mapDefinedEntries(Object.entries(pv), ([k, v])=>{
                return `,${encodeString(k)},${encodeValue(v)}`;
            }).join("");
            tmp = tmp.slice(1);
        } else {
            const k = (options === null || options === void 0 ? void 0 : options.explode) && (0, is_plain_object_js_1.isPlainObject)(value) ? `${pk}=` : "";
            tmp = `${k}${encodeValue(pv)}`;
        }
        // If we end up with the nothing then skip forward
        if (!tmp) {
            return;
        }
        out += `,${tmp}`;
    });
    return out.slice(1);
};
exports.encodeSimple = encodeSimple;
function explode(key, value) {
    if (Array.isArray(value)) {
        return value.map((v)=>[
                key,
                v
            ]);
    } else if ((0, is_plain_object_js_1.isPlainObject)(value)) {
        const o = value !== null && value !== void 0 ? value : {};
        return Object.entries(o).map(([k, v])=>[
                k,
                v
            ]);
    } else {
        return [
            [
                key,
                value
            ]
        ];
    }
}
function serializeValue(value) {
    if (value === null) {
        return "null";
    } else if (typeof value === "undefined") {
        return "";
    } else if (value instanceof Date) {
        return value.toISOString();
    } else if (value instanceof Uint8Array) {
        return (0, base64_js_1.bytesToBase64)(value);
    } else if (typeof value === "object") {
        return JSON.stringify(value, jsonReplacer);
    }
    return `${value}`;
}
function jsonReplacer(_, value) {
    if (value instanceof Uint8Array) {
        return (0, base64_js_1.bytesToBase64)(value);
    } else {
        return value;
    }
}
function mapDefined(inp, mapper) {
    return inp.reduce((acc, v)=>{
        if (v === undefined) {
            return acc;
        }
        const m = mapper(v);
        if (m === undefined) {
            return acc;
        }
        acc.push(m);
        return acc;
    }, []);
}
function mapDefinedEntries(inp, mapper) {
    const acc = [];
    for (const [k, v] of inp){
        if (v === undefined) {
            continue;
        }
        const m = mapper([
            k,
            v
        ]);
        if (m === undefined) {
            continue;
        }
        acc.push(m);
    }
    return acc;
}
function queryJoin(...args) {
    return args.filter(Boolean).join("&");
}
exports.queryJoin = queryJoin;
function queryEncoder(f) {
    const bulkEncode = function(values, options) {
        var _a, _b;
        const opts = {
            ...options,
            explode: (_a = options === null || options === void 0 ? void 0 : options.explode) !== null && _a !== void 0 ? _a : true,
            charEncoding: (_b = options === null || options === void 0 ? void 0 : options.charEncoding) !== null && _b !== void 0 ? _b : "percent"
        };
        const encoded = Object.entries(values).map(([key, value])=>{
            return f(key, value, opts);
        });
        return queryJoin(...encoded);
    };
    return bulkEncode;
}
exports.queryEncoder = queryEncoder;
exports.encodeJSONQuery = queryEncoder(encodeJSON);
exports.encodeFormQuery = queryEncoder(exports.encodeForm);
exports.encodeSpaceDelimitedQuery = queryEncoder(exports.encodeSpaceDelimited);
exports.encodePipeDelimitedQuery = queryEncoder(exports.encodePipeDelimited);
exports.encodeDeepObjectQuery = queryEncoder(encodeDeepObject); //# sourceMappingURL=encodings.js.map
}}),
"[project]/node_modules/unstructured-client/lib/sdks.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ClientSDK_httpClient, _ClientSDK_hooks, _ClientSDK_logger;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ClientSDK = void 0;
const hooks_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/hooks/hooks.js [app-rsc] (ecmascript)");
const httpclienterrors_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/errors/httpclienterrors.js [app-rsc] (ecmascript)");
const fp_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/sdk/types/fp.js [app-rsc] (ecmascript)");
const base64_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/base64.js [app-rsc] (ecmascript)");
const config_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/config.js [app-rsc] (ecmascript)");
const encodings_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/encodings.js [app-rsc] (ecmascript)");
const http_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/http.js [app-rsc] (ecmascript)");
const retries_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/retries.js [app-rsc] (ecmascript)");
const gt = typeof globalThis === "undefined" ? null : globalThis;
const webWorkerLike = typeof gt === "object" && gt != null && "importScripts" in gt && typeof gt["importScripts"] === "function";
const isBrowserLike = webWorkerLike || typeof navigator !== "undefined" && "serviceWorker" in navigator || "undefined" === "object" && typeof window.document !== "undefined";
class ClientSDK {
    constructor(options = {}){
        _ClientSDK_httpClient.set(this, void 0);
        _ClientSDK_hooks.set(this, void 0);
        _ClientSDK_logger.set(this, void 0);
        const opt = options;
        if (typeof opt === "object" && opt != null && "hooks" in opt && opt.hooks instanceof hooks_js_1.SDKHooks) {
            __classPrivateFieldSet(this, _ClientSDK_hooks, opt.hooks, "f");
        } else {
            __classPrivateFieldSet(this, _ClientSDK_hooks, new hooks_js_1.SDKHooks(), "f");
        }
        this._options = {
            ...options,
            hooks: __classPrivateFieldGet(this, _ClientSDK_hooks, "f")
        };
        const url = (0, config_js_1.serverURLFromOptions)(options);
        if (url) {
            url.pathname = url.pathname.replace(/\/+$/, "") + "/";
        }
        const { baseURL, client } = __classPrivateFieldGet(this, _ClientSDK_hooks, "f").sdkInit({
            baseURL: url,
            client: options.httpClient || new http_js_1.HTTPClient()
        });
        this._baseURL = baseURL;
        __classPrivateFieldSet(this, _ClientSDK_httpClient, client, "f");
        __classPrivateFieldSet(this, _ClientSDK_logger, options.debugLogger, "f");
    }
    _createRequest(context, conf, options) {
        var _a, _b, _c, _d;
        const { method, path, query, headers: opHeaders, security } = conf;
        const base = (_a = conf.baseURL) !== null && _a !== void 0 ? _a : this._baseURL;
        if (!base) {
            return (0, fp_js_1.ERR)(new httpclienterrors_js_1.InvalidRequestError("No base URL provided for operation"));
        }
        const reqURL = new URL(base);
        const inputURL = new URL(path, reqURL);
        if (path) {
            reqURL.pathname += inputURL.pathname.replace(/^\/+/, "");
        }
        let finalQuery = query || "";
        const secQuery = [];
        for (const [k, v] of Object.entries((security === null || security === void 0 ? void 0 : security.queryParams) || {})){
            secQuery.push((0, encodings_js_1.encodeForm)(k, v, {
                charEncoding: "percent"
            }));
        }
        if (secQuery.length) {
            finalQuery += `&${secQuery.join("&")}`;
        }
        if (finalQuery) {
            const q = finalQuery.startsWith("&") ? finalQuery.slice(1) : finalQuery;
            reqURL.search = `?${q}`;
        }
        const headers = new Headers(opHeaders);
        const username = security === null || security === void 0 ? void 0 : security.basic.username;
        const password = security === null || security === void 0 ? void 0 : security.basic.password;
        if (username != null || password != null) {
            const encoded = (0, base64_js_1.stringToBase64)([
                username || "",
                password || ""
            ].join(":"));
            headers.set("Authorization", `Basic ${encoded}`);
        }
        const securityHeaders = new Headers((security === null || security === void 0 ? void 0 : security.headers) || {});
        for (const [k, v] of securityHeaders){
            headers.set(k, v);
        }
        let cookie = headers.get("cookie") || "";
        for (const [k, v] of Object.entries((security === null || security === void 0 ? void 0 : security.cookies) || {})){
            cookie += `; ${k}=${v}`;
        }
        cookie = cookie.startsWith("; ") ? cookie.slice(2) : cookie;
        headers.set("cookie", cookie);
        const userHeaders = new Headers((_b = options === null || options === void 0 ? void 0 : options.fetchOptions) === null || _b === void 0 ? void 0 : _b.headers);
        for (const [k, v] of userHeaders){
            headers.set(k, v);
        }
        // Only set user agent header in non-browser-like environments since CORS
        // policy disallows setting it in browsers e.g. Chrome throws an error.
        if (!isBrowserLike) {
            headers.set((_c = conf.uaHeader) !== null && _c !== void 0 ? _c : "user-agent", config_js_1.SDK_METADATA.userAgent);
        }
        let fetchOptions = options === null || options === void 0 ? void 0 : options.fetchOptions;
        if (!(fetchOptions === null || fetchOptions === void 0 ? void 0 : fetchOptions.signal) && conf.timeoutMs && conf.timeoutMs > 0) {
            const timeoutSignal = AbortSignal.timeout(conf.timeoutMs);
            if (!fetchOptions) {
                fetchOptions = {
                    signal: timeoutSignal
                };
            } else {
                fetchOptions.signal = timeoutSignal;
            }
        }
        if (conf.body instanceof ReadableStream) {
            if (!fetchOptions) {
                fetchOptions = {
                    // @ts-expect-error see https://github.com/node-fetch/node-fetch/issues/1769
                    duplex: "half"
                };
            } else {
                // @ts-expect-error see https://github.com/node-fetch/node-fetch/issues/1769
                fetchOptions.duplex = "half";
            }
        }
        let input;
        try {
            input = __classPrivateFieldGet(this, _ClientSDK_hooks, "f").beforeCreateRequest(context, {
                url: reqURL,
                options: {
                    ...fetchOptions,
                    body: (_d = conf.body) !== null && _d !== void 0 ? _d : null,
                    headers,
                    method
                }
            });
        } catch (err) {
            return (0, fp_js_1.ERR)(new httpclienterrors_js_1.UnexpectedClientError("Create request hook failed to execute", {
                cause: err
            }));
        }
        return (0, fp_js_1.OK)(new Request(input.url, input.options));
    }
    async _do(request, options) {
        const { context, errorCodes } = options;
        const retryConfig = options.retryConfig || {
            strategy: "none"
        };
        const retryCodes = options.retryCodes || [];
        return (0, retries_js_1.retry)(async ()=>{
            const req = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").beforeRequest(context, request.clone());
            await logRequest(__classPrivateFieldGet(this, _ClientSDK_logger, "f"), req).catch((e)=>{
                var _a;
                return (_a = __classPrivateFieldGet(this, _ClientSDK_logger, "f")) === null || _a === void 0 ? void 0 : _a.log("Failed to log request:", e);
            });
            let response = await __classPrivateFieldGet(this, _ClientSDK_httpClient, "f").request(req);
            if ((0, http_js_1.matchStatusCode)(response, errorCodes)) {
                const result = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").afterError(context, response, null);
                if (result.error) {
                    throw result.error;
                }
                response = result.response || response;
            } else {
                response = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").afterSuccess(context, response);
            }
            await logResponse(__classPrivateFieldGet(this, _ClientSDK_logger, "f"), response, req).catch((e)=>{
                var _a;
                return (_a = __classPrivateFieldGet(this, _ClientSDK_logger, "f")) === null || _a === void 0 ? void 0 : _a.log("Failed to log response:", e);
            });
            return response;
        }, {
            config: retryConfig,
            statusCodes: retryCodes
        }).then((r)=>(0, fp_js_1.OK)(r), (err)=>{
            switch(true){
                case (0, http_js_1.isAbortError)(err):
                    return (0, fp_js_1.ERR)(new httpclienterrors_js_1.RequestAbortedError("Request aborted by client", {
                        cause: err
                    }));
                case (0, http_js_1.isTimeoutError)(err):
                    return (0, fp_js_1.ERR)(new httpclienterrors_js_1.RequestTimeoutError("Request timed out", {
                        cause: err
                    }));
                case (0, http_js_1.isConnectionError)(err):
                    return (0, fp_js_1.ERR)(new httpclienterrors_js_1.ConnectionError("Unable to make request", {
                        cause: err
                    }));
                default:
                    return (0, fp_js_1.ERR)(new httpclienterrors_js_1.UnexpectedClientError("Unexpected HTTP client error", {
                        cause: err
                    }));
            }
        });
    }
}
exports.ClientSDK = ClientSDK;
_ClientSDK_httpClient = new WeakMap(), _ClientSDK_hooks = new WeakMap(), _ClientSDK_logger = new WeakMap();
const jsonLikeContentTypeRE = /^application\/(?:.{0,100}\+)?json/;
async function logRequest(logger, req) {
    if (!logger) {
        return;
    }
    const contentType = req.headers.get("content-type");
    const ct = (contentType === null || contentType === void 0 ? void 0 : contentType.split(";")[0]) || "";
    logger.group(`> Request: ${req.method} ${req.url}`);
    logger.group("Headers:");
    for (const [k, v] of req.headers.entries()){
        logger.log(`${k}: ${v}`);
    }
    logger.groupEnd();
    logger.group("Body:");
    switch(true){
        case jsonLikeContentTypeRE.test(ct):
            logger.log(await req.clone().json());
            break;
        case ct.startsWith("text/"):
            logger.log(await req.clone().text());
            break;
        case ct === "multipart/form-data":
            {
                const body = await req.clone().formData();
                for (const [k, v] of body){
                    const vlabel = v instanceof Blob ? "<Blob>" : v;
                    logger.log(`${k}: ${vlabel}`);
                }
                break;
            }
        default:
            logger.log(`<${contentType}>`);
            break;
    }
    logger.groupEnd();
    logger.groupEnd();
}
async function logResponse(logger, res, req) {
    if (!logger) {
        return;
    }
    const contentType = res.headers.get("content-type");
    const ct = (contentType === null || contentType === void 0 ? void 0 : contentType.split(";")[0]) || "";
    logger.group(`< Response: ${req.method} ${req.url}`);
    logger.log("Status Code:", res.status, res.statusText);
    logger.group("Headers:");
    for (const [k, v] of res.headers.entries()){
        logger.log(`${k}: ${v}`);
    }
    logger.groupEnd();
    logger.group("Body:");
    switch(true){
        case (0, http_js_1.matchContentType)(res, "application/json") || jsonLikeContentTypeRE.test(ct):
            logger.log(await res.clone().json());
            break;
        case (0, http_js_1.matchContentType)(res, "text/event-stream"):
            logger.log(`<${contentType}>`);
            break;
        case (0, http_js_1.matchContentType)(res, "text/*"):
            logger.log(await res.clone().text());
            break;
        case (0, http_js_1.matchContentType)(res, "multipart/form-data"):
            {
                const body = await res.clone().formData();
                for (const [k, v] of body){
                    const vlabel = v instanceof Blob ? "<Blob>" : v;
                    logger.log(`${k}: ${vlabel}`);
                }
                break;
            }
        default:
            logger.log(`<${contentType}>`);
            break;
    }
    logger.groupEnd();
    logger.groupEnd();
} //# sourceMappingURL=sdks.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/models/errors/sdkerror.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SDKError = void 0;
class SDKError extends Error {
    constructor(message, rawResponse, body = ""){
        const statusCode = rawResponse.status;
        const contentType = rawResponse.headers.get("content-type") || "";
        const bodyString = body.length > 0 ? `\n${body}` : "";
        super(`${message}: Status ${statusCode} Content-Type ${contentType} Body ${bodyString}`);
        this.rawResponse = rawResponse;
        this.body = body;
        this.statusCode = statusCode;
        this.contentType = contentType;
        this.name = "SDKError";
    }
}
exports.SDKError = SDKError; //# sourceMappingURL=sdkerror.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/models/errors/sdkvalidationerror.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.formatZodError = exports.SDKValidationError = void 0;
const z = __importStar(__turbopack_require__("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)"));
class SDKValidationError extends Error {
    constructor(message, cause, rawValue){
        super(`${message}: ${cause}`);
        this.name = "SDKValidationError";
        this.cause = cause;
        this.rawValue = rawValue;
        this.rawMessage = message;
    }
    /**
     * Return a pretty-formatted error message if the underlying validation error
     * is a ZodError or some other recognized error type, otherwise return the
     * default error message.
     */ pretty() {
        if (this.cause instanceof z.ZodError) {
            return `${this.rawMessage}\n${formatZodError(this.cause)}`;
        } else {
            return this.toString();
        }
    }
}
exports.SDKValidationError = SDKValidationError;
function formatZodError(err, level = 0) {
    let pre = "  ".repeat(level);
    pre = level > 0 ? `${pre}` : pre;
    pre += " ".repeat(level);
    let message = "";
    const append = (str)=>message += `\n${pre}${str}`;
    const len = err.issues.length;
    const headline = len === 1 ? `${len} issue found` : `${len} issues found`;
    if (len) {
        append(` ${headline}:`);
    }
    for (const issue of err.issues){
        let path = issue.path.join(".");
        path = path ? `<root>.${path}` : "<root>";
        append(`  [${path}]: ${issue.message} (${issue.code})`);
        switch(issue.code){
            case "invalid_literal":
            case "invalid_type":
                {
                    append(`     Want: ${issue.expected}`);
                    append(`      Got: ${issue.received}`);
                    break;
                }
            case "unrecognized_keys":
                {
                    append(`     Keys: ${issue.keys.join(", ")}`);
                    break;
                }
            case "invalid_enum_value":
                {
                    append(`     Allowed: ${issue.options.join(", ")}`);
                    append(`         Got: ${issue.received}`);
                    break;
                }
            case "invalid_union_discriminator":
                {
                    append(`     Allowed: ${issue.options.join(", ")}`);
                    break;
                }
            case "invalid_union":
                {
                    const len = issue.unionErrors.length;
                    append(`    Attemped to deserialize into one of ${len} union members:`);
                    issue.unionErrors.forEach((err, i)=>{
                        append(`    Member ${i + 1} of ${len}`);
                        append(`${formatZodError(err, level + 1)}`);
                    });
                }
        }
    }
    if (err.issues.length) {
        append(`*`);
    }
    return message.slice(1);
}
exports.formatZodError = formatZodError; //# sourceMappingURL=sdkvalidationerror.js.map
}}),
"[project]/node_modules/unstructured-client/lib/schemas.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.collectExtraKeys = exports.safeParse = exports.parse = void 0;
const zod_1 = __turbopack_require__("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)");
const sdkvalidationerror_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/errors/sdkvalidationerror.js [app-rsc] (ecmascript)");
const fp_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/sdk/types/fp.js [app-rsc] (ecmascript)");
/**
 * Utility function that executes some code which may throw a ZodError. It
 * intercepts this error and converts it to an SDKValidationError so as to not
 * leak Zod implementation details to user code.
 */ function parse(rawValue, fn, errorMessage) {
    try {
        return fn(rawValue);
    } catch (err) {
        if (err instanceof zod_1.ZodError) {
            throw new sdkvalidationerror_js_1.SDKValidationError(errorMessage, err, rawValue);
        }
        throw err;
    }
}
exports.parse = parse;
/**
 * Utility function that executes some code which may result in a ZodError. It
 * intercepts this error and converts it to an SDKValidationError so as to not
 * leak Zod implementation details to user code.
 */ function safeParse(rawValue, fn, errorMessage) {
    try {
        return (0, fp_js_1.OK)(fn(rawValue));
    } catch (err) {
        return (0, fp_js_1.ERR)(new sdkvalidationerror_js_1.SDKValidationError(errorMessage, err, rawValue));
    }
}
exports.safeParse = safeParse;
function collectExtraKeys(obj, extrasKey) {
    return obj.transform((val)=>{
        const extras = {};
        const { shape } = obj;
        for (const [key] of Object.entries(val)){
            if (key in shape) {
                continue;
            }
            const v = val[key];
            if (typeof v === "undefined") {
                continue;
            }
            extras[key] = v;
            delete val[key];
        }
        return {
            ...val,
            [extrasKey]: extras
        };
    });
}
exports.collectExtraKeys = collectExtraKeys; //# sourceMappingURL=schemas.js.map
}}),
"[project]/node_modules/unstructured-client/lib/matchers.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.discardResponseBody = exports.unpackHeaders = exports.match = exports.fail = exports.nil = exports.nilErr = exports.sse = exports.sseErr = exports.stream = exports.streamErr = exports.bytes = exports.bytesErr = exports.text = exports.textErr = exports.json = exports.jsonErr = void 0;
const sdkerror_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/errors/sdkerror.js [app-rsc] (ecmascript)");
const http_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/http.js [app-rsc] (ecmascript)");
const is_plain_object_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/is-plain-object.js [app-rsc] (ecmascript)");
const schemas_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/schemas.js [app-rsc] (ecmascript)");
const DEFAULT_CONTENT_TYPES = {
    json: "application/json",
    text: "text/plain",
    bytes: "application/octet-stream",
    stream: "application/octet-stream",
    sse: "text/event-stream",
    nil: "*",
    fail: "*"
};
function jsonErr(codes, schema, options) {
    return {
        ...options,
        err: true,
        enc: "json",
        codes,
        schema
    };
}
exports.jsonErr = jsonErr;
function json(codes, schema, options) {
    return {
        ...options,
        enc: "json",
        codes,
        schema
    };
}
exports.json = json;
function textErr(codes, schema, options) {
    return {
        ...options,
        err: true,
        enc: "text",
        codes,
        schema
    };
}
exports.textErr = textErr;
function text(codes, schema, options) {
    return {
        ...options,
        enc: "text",
        codes,
        schema
    };
}
exports.text = text;
function bytesErr(codes, schema, options) {
    return {
        ...options,
        err: true,
        enc: "bytes",
        codes,
        schema
    };
}
exports.bytesErr = bytesErr;
function bytes(codes, schema, options) {
    return {
        ...options,
        enc: "bytes",
        codes,
        schema
    };
}
exports.bytes = bytes;
function streamErr(codes, schema, options) {
    return {
        ...options,
        err: true,
        enc: "stream",
        codes,
        schema
    };
}
exports.streamErr = streamErr;
function stream(codes, schema, options) {
    return {
        ...options,
        enc: "stream",
        codes,
        schema
    };
}
exports.stream = stream;
function sseErr(codes, schema, options) {
    return {
        ...options,
        err: true,
        enc: "sse",
        codes,
        schema
    };
}
exports.sseErr = sseErr;
function sse(codes, schema, options) {
    return {
        ...options,
        enc: "sse",
        codes,
        schema
    };
}
exports.sse = sse;
function nilErr(codes, schema, options) {
    return {
        ...options,
        err: true,
        enc: "nil",
        codes,
        schema
    };
}
exports.nilErr = nilErr;
function nil(codes, schema, options) {
    return {
        ...options,
        enc: "nil",
        codes,
        schema
    };
}
exports.nil = nil;
function fail(codes) {
    return {
        enc: "fail",
        codes
    };
}
exports.fail = fail;
function match(...matchers) {
    return async function matchFunc(response, options) {
        let raw;
        let matcher;
        for (const match of matchers){
            const { codes } = match;
            const ctpattern = "ctype" in match ? match.ctype : DEFAULT_CONTENT_TYPES[match.enc];
            if (ctpattern && (0, http_js_1.matchResponse)(response, codes, ctpattern)) {
                matcher = match;
                break;
            } else if (!ctpattern && (0, http_js_1.matchStatusCode)(response, codes)) {
                matcher = match;
                break;
            }
        }
        if (!matcher) {
            const responseBody = await response.text();
            return [
                {
                    ok: false,
                    error: new sdkerror_js_1.SDKError("Unexpected API response status or content-type", response, responseBody)
                },
                responseBody
            ];
        }
        const encoding = matcher.enc;
        switch(encoding){
            case "json":
                raw = await response.json();
                break;
            case "bytes":
                raw = await response.arrayBuffer();
                break;
            case "stream":
                raw = response.body;
                break;
            case "text":
                raw = await response.text();
                break;
            case "sse":
                raw = response.body;
                break;
            case "nil":
                raw = await discardResponseBody(response);
                break;
            case "fail":
                raw = await response.text();
                break;
            default:
                encoding;
                throw new Error(`Unsupported response type: ${encoding}`);
        }
        if (matcher.enc === "fail") {
            return [
                {
                    ok: false,
                    error: new sdkerror_js_1.SDKError("API error occurred", response, typeof raw === "string" ? raw : "")
                },
                raw
            ];
        }
        const resultKey = matcher.key || (options === null || options === void 0 ? void 0 : options.resultKey);
        let data;
        if ("err" in matcher) {
            data = {
                ...options === null || options === void 0 ? void 0 : options.extraFields,
                ...matcher.hdrs ? {
                    Headers: unpackHeaders(response.headers)
                } : null,
                ...(0, is_plain_object_js_1.isPlainObject)(raw) ? raw : null
            };
        } else if (resultKey) {
            data = {
                ...options === null || options === void 0 ? void 0 : options.extraFields,
                ...matcher.hdrs ? {
                    Headers: unpackHeaders(response.headers)
                } : null,
                [resultKey]: raw
            };
        } else {
            data = {
                ...options === null || options === void 0 ? void 0 : options.extraFields,
                ...matcher.hdrs ? {
                    Headers: unpackHeaders(response.headers)
                } : null
            };
        }
        if ("err" in matcher) {
            const result = (0, schemas_js_1.safeParse)(data, (v)=>matcher.schema.parse(v), "Response validation failed");
            return [
                result.ok ? {
                    ok: false,
                    error: result.value
                } : result,
                raw
            ];
        } else {
            return [
                (0, schemas_js_1.safeParse)(data, (v)=>matcher.schema.parse(v), "Response validation failed"),
                raw
            ];
        }
    };
}
exports.match = match;
const headerValRE = /, */;
/**
 * Iterates over a Headers object and returns an object with all the header
 * entries. Values are represented as an array to account for repeated headers.
 */ function unpackHeaders(headers) {
    const out = {};
    for (const [k, v] of headers.entries()){
        out[k] = v.split(headerValRE);
    }
    return out;
}
exports.unpackHeaders = unpackHeaders;
/**
 * Discards the response body to free up resources.
 *
 * To learn why this is need, see the undici docs:
 * https://undici.nodejs.org/#/?id=garbage-collection
 */ async function discardResponseBody(res) {
    var _a;
    const reader = (_a = res.body) === null || _a === void 0 ? void 0 : _a.getReader();
    if (reader == null) {
        return;
    }
    try {
        let done = false;
        while(!done){
            const res = await reader.read();
            done = res.done;
        }
    } finally{
        reader.releaseLock();
    }
}
exports.discardResponseBody = discardResponseBody; //# sourceMappingURL=matchers.js.map
}}),
"[project]/node_modules/unstructured-client/lib/security.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extractSecurity = exports.resolveGlobalSecurity = exports.resolveSecurity = exports.SecurityError = exports.SecurityErrorCode = void 0;
var SecurityErrorCode;
(function(SecurityErrorCode) {
    SecurityErrorCode["Incomplete"] = "incomplete";
    SecurityErrorCode["UnrecognisedSecurityType"] = "unrecognized_security_type";
})(SecurityErrorCode || (exports.SecurityErrorCode = SecurityErrorCode = {}));
class SecurityError extends Error {
    constructor(code, message){
        super(message);
        this.code = code;
        this.name = "SecurityError";
    }
    static incomplete() {
        return new SecurityError(SecurityErrorCode.Incomplete, "Security requirements not met in order to perform the operation");
    }
    static unrecognizedType(type) {
        return new SecurityError(SecurityErrorCode.UnrecognisedSecurityType, `Unrecognised security type: ${type}`);
    }
}
exports.SecurityError = SecurityError;
function resolveSecurity(...options) {
    const state = {
        basic: {
            username: "",
            password: ""
        },
        headers: {},
        queryParams: {},
        cookies: {}
    };
    const option = options.find((opts)=>{
        return opts.every((o)=>{
            if (o.value == null) {
                return false;
            } else if (o.type === "http:basic") {
                return o.value.username != null || o.value.password != null;
            } else if (o.type === "http:custom") {
                return null;
            } else if (typeof o.value === "string") {
                return !!o.value;
            } else {
                throw new Error(`Unrecognized security type: ${o.type} (value type: ${typeof o.value})`);
            }
        });
    });
    if (option == null) {
        return null;
    }
    option.forEach((spec)=>{
        if (spec.value == null) {
            return;
        }
        const { type } = spec;
        switch(type){
            case "apiKey:header":
                state.headers[spec.fieldName] = spec.value;
                break;
            case "apiKey:query":
                state.queryParams[spec.fieldName] = spec.value;
                break;
            case "apiKey:cookie":
                state.cookies[spec.fieldName] = spec.value;
                break;
            case "http:basic":
                applyBasic(state, spec);
                break;
            case "http:custom":
                break;
            case "http:bearer":
                applyBearer(state, spec);
                break;
            case "oauth2":
                applyBearer(state, spec);
                break;
            case "oauth2:client_credentials":
                break;
            case "openIdConnect":
                applyBearer(state, spec);
                break;
            default:
                spec;
                throw SecurityError.unrecognizedType(type);
        }
    });
    return state;
}
exports.resolveSecurity = resolveSecurity;
function applyBasic(state, spec) {
    if (spec.value == null) {
        return;
    }
    state.basic = spec.value;
}
function applyBearer(state, spec) {
    if (spec.value == null) {
        return;
    }
    let value = spec.value;
    if (value.slice(0, 7).toLowerCase() !== "bearer ") {
        value = `Bearer ${value}`;
    }
    state.headers[spec.fieldName] = value;
}
function resolveGlobalSecurity(security) {
    return resolveSecurity([
        {
            fieldName: "unstructured-api-key",
            type: "apiKey:header",
            value: security === null || security === void 0 ? void 0 : security.apiKeyAuth
        }
    ]);
}
exports.resolveGlobalSecurity = resolveGlobalSecurity;
async function extractSecurity(sec) {
    if (sec == null) {
        return;
    }
    return typeof sec === "function" ? sec() : sec;
}
exports.extractSecurity = extractSecurity; //# sourceMappingURL=security.js.map
}}),
"[project]/node_modules/unstructured-client/lib/primitives.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.remap = void 0;
/**
 * Converts or omits an object's keys according to a mapping.
 *
 * @param inp An object whose keys will be remapped
 * @param mappings A mapping of original keys to new keys. If a key is not present in the mapping, it will be left as is. If a key is mapped to `null`, it will be removed in the resulting object.
 * @returns A new object with keys remapped or omitted according to the mappings
 */ function remap(inp, mappings) {
    let out = {};
    if (!Object.keys(mappings).length) {
        out = inp;
        return out;
    }
    for (const [k, v] of Object.entries(inp)){
        const j = mappings[k];
        if (j === null) {
            continue;
        }
        out[j !== null && j !== void 0 ? j : k] = v;
    }
    return out;
}
exports.remap = remap; //# sourceMappingURL=primitives.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/types/blobs.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isBlobLike = exports.blobLikeSchema = void 0;
const z = __importStar(__turbopack_require__("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)"));
exports.blobLikeSchema = z.custom(isBlobLike, {
    message: "expected a Blob, File or Blob-like object",
    fatal: true
});
function isBlobLike(val) {
    if (val instanceof Blob) {
        return true;
    }
    if (typeof val !== "object" || val == null || !(Symbol.toStringTag in val)) {
        return false;
    }
    const name = val[Symbol.toStringTag];
    if (typeof name !== "string") {
        return false;
    }
    if (name !== "Blob" && name !== "File") {
        return false;
    }
    return "stream" in val && typeof val.stream === "function";
}
exports.isBlobLike = isBlobLike; //# sourceMappingURL=blobs.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/types/enums.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.catchUnrecognizedEnum = void 0;
function catchUnrecognizedEnum(value) {
    return value;
}
exports.catchUnrecognizedEnum = catchUnrecognizedEnum; //# sourceMappingURL=enums.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/models/shared/partitionparameters.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PartitionParameters$ = exports.PartitionParameters$outboundSchema = exports.PartitionParameters$inboundSchema = exports.Strategy$ = exports.Strategy$outboundSchema = exports.Strategy$inboundSchema = exports.OutputFormat$ = exports.OutputFormat$outboundSchema = exports.OutputFormat$inboundSchema = exports.Files$ = exports.Files$outboundSchema = exports.Files$inboundSchema = exports.ChunkingStrategy$ = exports.ChunkingStrategy$outboundSchema = exports.ChunkingStrategy$inboundSchema = exports.Strategy = exports.OutputFormat = exports.ChunkingStrategy = void 0;
const z = __importStar(__turbopack_require__("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)"));
const primitives_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/primitives.js [app-rsc] (ecmascript)");
const blobs_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/sdk/types/blobs.js [app-rsc] (ecmascript)");
const enums_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/sdk/types/enums.js [app-rsc] (ecmascript)");
var ChunkingStrategy;
(function(ChunkingStrategy) {
    ChunkingStrategy["Basic"] = "basic";
    ChunkingStrategy["ByPage"] = "by_page";
    ChunkingStrategy["BySimilarity"] = "by_similarity";
    ChunkingStrategy["ByTitle"] = "by_title";
})(ChunkingStrategy || (exports.ChunkingStrategy = ChunkingStrategy = {}));
/**
 * The format of the response. Supported formats are application/json and text/csv. Default: application/json.
 */ var OutputFormat;
(function(OutputFormat) {
    OutputFormat["ApplicationJson"] = "application/json";
    OutputFormat["TextCsv"] = "text/csv";
})(OutputFormat || (exports.OutputFormat = OutputFormat = {}));
/**
 * The strategy to use for partitioning PDF/image. Options are fast, hi_res, auto. Default: hi_res
 */ var Strategy;
(function(Strategy) {
    Strategy["Fast"] = "fast";
    Strategy["HiRes"] = "hi_res";
    Strategy["Auto"] = "auto";
    Strategy["OcrOnly"] = "ocr_only";
})(Strategy || (exports.Strategy = Strategy = {}));
/** @internal */ exports.ChunkingStrategy$inboundSchema = z.union([
    z.nativeEnum(ChunkingStrategy),
    z.string().transform(enums_js_1.catchUnrecognizedEnum)
]);
/** @internal */ exports.ChunkingStrategy$outboundSchema = z.union([
    z.nativeEnum(ChunkingStrategy),
    z.string().and(z.custom())
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */ var ChunkingStrategy$;
(function(ChunkingStrategy$) {
    /** @deprecated use `ChunkingStrategy$inboundSchema` instead. */ ChunkingStrategy$.inboundSchema = exports.ChunkingStrategy$inboundSchema;
    /** @deprecated use `ChunkingStrategy$outboundSchema` instead. */ ChunkingStrategy$.outboundSchema = exports.ChunkingStrategy$outboundSchema;
})(ChunkingStrategy$ || (exports.ChunkingStrategy$ = ChunkingStrategy$ = {}));
/** @internal */ exports.Files$inboundSchema = z.object({
    content: z.union([
        z.instanceof(ReadableStream),
        z.instanceof(Blob),
        z.instanceof(ArrayBuffer),
        z.instanceof(Uint8Array)
    ]),
    fileName: z.string()
});
/** @internal */ exports.Files$outboundSchema = z.object({
    content: z.union([
        z.instanceof(ReadableStream),
        z.instanceof(Blob),
        z.instanceof(ArrayBuffer),
        z.instanceof(Uint8Array)
    ]),
    fileName: z.string()
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */ var Files$;
(function(Files$) {
    /** @deprecated use `Files$inboundSchema` instead. */ Files$.inboundSchema = exports.Files$inboundSchema;
    /** @deprecated use `Files$outboundSchema` instead. */ Files$.outboundSchema = exports.Files$outboundSchema;
})(Files$ || (exports.Files$ = Files$ = {}));
/** @internal */ exports.OutputFormat$inboundSchema = z.union([
    z.nativeEnum(OutputFormat),
    z.string().transform(enums_js_1.catchUnrecognizedEnum)
]);
/** @internal */ exports.OutputFormat$outboundSchema = z.union([
    z.nativeEnum(OutputFormat),
    z.string().and(z.custom())
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */ var OutputFormat$;
(function(OutputFormat$) {
    /** @deprecated use `OutputFormat$inboundSchema` instead. */ OutputFormat$.inboundSchema = exports.OutputFormat$inboundSchema;
    /** @deprecated use `OutputFormat$outboundSchema` instead. */ OutputFormat$.outboundSchema = exports.OutputFormat$outboundSchema;
})(OutputFormat$ || (exports.OutputFormat$ = OutputFormat$ = {}));
/** @internal */ exports.Strategy$inboundSchema = z.union([
    z.nativeEnum(Strategy),
    z.string().transform(enums_js_1.catchUnrecognizedEnum)
]);
/** @internal */ exports.Strategy$outboundSchema = z.union([
    z.nativeEnum(Strategy),
    z.string().and(z.custom())
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */ var Strategy$;
(function(Strategy$) {
    /** @deprecated use `Strategy$inboundSchema` instead. */ Strategy$.inboundSchema = exports.Strategy$inboundSchema;
    /** @deprecated use `Strategy$outboundSchema` instead. */ Strategy$.outboundSchema = exports.Strategy$outboundSchema;
})(Strategy$ || (exports.Strategy$ = Strategy$ = {}));
/** @internal */ exports.PartitionParameters$inboundSchema = z.object({
    files: z.lazy(()=>exports.Files$inboundSchema),
    chunking_strategy: z.nullable(exports.ChunkingStrategy$inboundSchema).optional(),
    combine_under_n_chars: z.nullable(z.number().int()).optional(),
    content_type: z.nullable(z.string()).optional(),
    coordinates: z.boolean().default(false),
    encoding: z.nullable(z.string()).optional(),
    extract_image_block_types: z.array(z.string()).optional(),
    gz_uncompressed_content_type: z.nullable(z.string()).optional(),
    hi_res_model_name: z.nullable(z.string()).optional(),
    include_orig_elements: z.nullable(z.boolean()).optional(),
    include_page_breaks: z.boolean().default(false),
    include_slide_notes: z.boolean().default(true),
    languages: z.array(z.string()).optional(),
    max_characters: z.nullable(z.number().int()).optional(),
    multipage_sections: z.boolean().default(true),
    new_after_n_chars: z.nullable(z.number().int()).optional(),
    ocr_languages: z.array(z.string()).optional(),
    output_format: exports.OutputFormat$inboundSchema.default(OutputFormat.ApplicationJson),
    overlap: z.number().int().default(0),
    overlap_all: z.boolean().default(false),
    pdf_infer_table_structure: z.boolean().default(true),
    similarity_threshold: z.nullable(z.number()).optional(),
    skip_infer_table_types: z.array(z.string()).optional(),
    split_pdf_allow_failed: z.boolean().default(false),
    split_pdf_concurrency_level: z.number().int().default(5),
    split_pdf_page: z.boolean().default(true),
    split_pdf_page_range: z.array(z.number().int()).optional(),
    starting_page_number: z.nullable(z.number().int()).optional(),
    strategy: exports.Strategy$inboundSchema.default(Strategy.HiRes),
    unique_element_ids: z.boolean().default(false),
    xml_keep_tags: z.boolean().default(false)
}).transform((v)=>{
    return (0, primitives_js_1.remap)(v, {
        "chunking_strategy": "chunkingStrategy",
        "combine_under_n_chars": "combineUnderNChars",
        "content_type": "contentType",
        "extract_image_block_types": "extractImageBlockTypes",
        "gz_uncompressed_content_type": "gzUncompressedContentType",
        "hi_res_model_name": "hiResModelName",
        "include_orig_elements": "includeOrigElements",
        "include_page_breaks": "includePageBreaks",
        "include_slide_notes": "includeSlideNotes",
        "max_characters": "maxCharacters",
        "multipage_sections": "multipageSections",
        "new_after_n_chars": "newAfterNChars",
        "ocr_languages": "ocrLanguages",
        "output_format": "outputFormat",
        "overlap_all": "overlapAll",
        "pdf_infer_table_structure": "pdfInferTableStructure",
        "similarity_threshold": "similarityThreshold",
        "skip_infer_table_types": "skipInferTableTypes",
        "split_pdf_allow_failed": "splitPdfAllowFailed",
        "split_pdf_concurrency_level": "splitPdfConcurrencyLevel",
        "split_pdf_page": "splitPdfPage",
        "split_pdf_page_range": "splitPdfPageRange",
        "starting_page_number": "startingPageNumber",
        "unique_element_ids": "uniqueElementIds",
        "xml_keep_tags": "xmlKeepTags"
    });
});
/** @internal */ exports.PartitionParameters$outboundSchema = z.object({
    files: z.lazy(()=>exports.Files$outboundSchema).or(blobs_js_1.blobLikeSchema),
    chunkingStrategy: z.nullable(exports.ChunkingStrategy$outboundSchema).optional(),
    combineUnderNChars: z.nullable(z.number().int()).optional(),
    contentType: z.nullable(z.string()).optional(),
    coordinates: z.boolean().default(false),
    encoding: z.nullable(z.string()).optional(),
    extractImageBlockTypes: z.array(z.string()).optional(),
    gzUncompressedContentType: z.nullable(z.string()).optional(),
    hiResModelName: z.nullable(z.string()).optional(),
    includeOrigElements: z.nullable(z.boolean()).optional(),
    includePageBreaks: z.boolean().default(false),
    includeSlideNotes: z.boolean().default(true),
    languages: z.array(z.string()).optional(),
    maxCharacters: z.nullable(z.number().int()).optional(),
    multipageSections: z.boolean().default(true),
    newAfterNChars: z.nullable(z.number().int()).optional(),
    ocrLanguages: z.array(z.string()).optional(),
    outputFormat: exports.OutputFormat$outboundSchema.default(OutputFormat.ApplicationJson),
    overlap: z.number().int().default(0),
    overlapAll: z.boolean().default(false),
    pdfInferTableStructure: z.boolean().default(true),
    similarityThreshold: z.nullable(z.number()).optional(),
    skipInferTableTypes: z.array(z.string()).optional(),
    splitPdfAllowFailed: z.boolean().default(false),
    splitPdfConcurrencyLevel: z.number().int().default(5),
    splitPdfPage: z.boolean().default(true),
    splitPdfPageRange: z.array(z.number().int()).optional(),
    startingPageNumber: z.nullable(z.number().int()).optional(),
    strategy: exports.Strategy$outboundSchema.default(Strategy.HiRes),
    uniqueElementIds: z.boolean().default(false),
    xmlKeepTags: z.boolean().default(false)
}).transform((v)=>{
    return (0, primitives_js_1.remap)(v, {
        chunkingStrategy: "chunking_strategy",
        combineUnderNChars: "combine_under_n_chars",
        contentType: "content_type",
        extractImageBlockTypes: "extract_image_block_types",
        gzUncompressedContentType: "gz_uncompressed_content_type",
        hiResModelName: "hi_res_model_name",
        includeOrigElements: "include_orig_elements",
        includePageBreaks: "include_page_breaks",
        includeSlideNotes: "include_slide_notes",
        maxCharacters: "max_characters",
        multipageSections: "multipage_sections",
        newAfterNChars: "new_after_n_chars",
        ocrLanguages: "ocr_languages",
        outputFormat: "output_format",
        overlapAll: "overlap_all",
        pdfInferTableStructure: "pdf_infer_table_structure",
        similarityThreshold: "similarity_threshold",
        skipInferTableTypes: "skip_infer_table_types",
        splitPdfAllowFailed: "split_pdf_allow_failed",
        splitPdfConcurrencyLevel: "split_pdf_concurrency_level",
        splitPdfPage: "split_pdf_page",
        splitPdfPageRange: "split_pdf_page_range",
        startingPageNumber: "starting_page_number",
        uniqueElementIds: "unique_element_ids",
        xmlKeepTags: "xml_keep_tags"
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */ var PartitionParameters$;
(function(PartitionParameters$) {
    /** @deprecated use `PartitionParameters$inboundSchema` instead. */ PartitionParameters$.inboundSchema = exports.PartitionParameters$inboundSchema;
    /** @deprecated use `PartitionParameters$outboundSchema` instead. */ PartitionParameters$.outboundSchema = exports.PartitionParameters$outboundSchema;
})(PartitionParameters$ || (exports.PartitionParameters$ = PartitionParameters$ = {})); //# sourceMappingURL=partitionparameters.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/models/shared/security.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Security$ = exports.Security$outboundSchema = exports.Security$inboundSchema = void 0;
const z = __importStar(__turbopack_require__("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)"));
const primitives_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/primitives.js [app-rsc] (ecmascript)");
/** @internal */ exports.Security$inboundSchema = z.object({
    ApiKeyAuth: z.string().optional()
}).transform((v)=>{
    return (0, primitives_js_1.remap)(v, {
        "ApiKeyAuth": "apiKeyAuth"
    });
});
/** @internal */ exports.Security$outboundSchema = z.object({
    apiKeyAuth: z.string().optional()
}).transform((v)=>{
    return (0, primitives_js_1.remap)(v, {
        apiKeyAuth: "ApiKeyAuth"
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */ var Security$;
(function(Security$) {
    /** @deprecated use `Security$inboundSchema` instead. */ Security$.inboundSchema = exports.Security$inboundSchema;
    /** @deprecated use `Security$outboundSchema` instead. */ Security$.outboundSchema = exports.Security$outboundSchema;
})(Security$ || (exports.Security$ = Security$ = {})); //# sourceMappingURL=security.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/models/shared/validationerror.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ValidationError$ = exports.ValidationError$outboundSchema = exports.ValidationError$inboundSchema = exports.Loc$ = exports.Loc$outboundSchema = exports.Loc$inboundSchema = void 0;
const z = __importStar(__turbopack_require__("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)"));
/** @internal */ exports.Loc$inboundSchema = z.union([
    z.string(),
    z.number().int()
]);
/** @internal */ exports.Loc$outboundSchema = z.union([
    z.string(),
    z.number().int()
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */ var Loc$;
(function(Loc$) {
    /** @deprecated use `Loc$inboundSchema` instead. */ Loc$.inboundSchema = exports.Loc$inboundSchema;
    /** @deprecated use `Loc$outboundSchema` instead. */ Loc$.outboundSchema = exports.Loc$outboundSchema;
})(Loc$ || (exports.Loc$ = Loc$ = {}));
/** @internal */ exports.ValidationError$inboundSchema = z.object({
    loc: z.array(z.union([
        z.string(),
        z.number().int()
    ])),
    msg: z.string(),
    type: z.string()
});
/** @internal */ exports.ValidationError$outboundSchema = z.object({
    loc: z.array(z.union([
        z.string(),
        z.number().int()
    ])),
    msg: z.string(),
    type: z.string()
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */ var ValidationError$;
(function(ValidationError$) {
    /** @deprecated use `ValidationError$inboundSchema` instead. */ ValidationError$.inboundSchema = exports.ValidationError$inboundSchema;
    /** @deprecated use `ValidationError$outboundSchema` instead. */ ValidationError$.outboundSchema = exports.ValidationError$outboundSchema;
})(ValidationError$ || (exports.ValidationError$ = ValidationError$ = {})); //# sourceMappingURL=validationerror.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/models/shared/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/shared/partitionparameters.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/shared/security.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/shared/validationerror.js [app-rsc] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/models/errors/httpvalidationerror.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HTTPValidationError$ = exports.HTTPValidationError$outboundSchema = exports.HTTPValidationError$inboundSchema = exports.Detail$ = exports.Detail$outboundSchema = exports.Detail$inboundSchema = exports.HTTPValidationError = void 0;
const z = __importStar(__turbopack_require__("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)"));
const shared = __importStar(__turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/shared/index.js [app-rsc] (ecmascript)"));
class HTTPValidationError extends Error {
    constructor(err){
        const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
        super(message);
        this.data$ = err;
        if (err.detail != null) this.detail = err.detail;
        this.name = "HTTPValidationError";
    }
}
exports.HTTPValidationError = HTTPValidationError;
/** @internal */ exports.Detail$inboundSchema = z.union([
    z.array(shared.ValidationError$inboundSchema),
    z.string()
]);
/** @internal */ exports.Detail$outboundSchema = z.union([
    z.array(shared.ValidationError$outboundSchema),
    z.string()
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */ var Detail$;
(function(Detail$) {
    /** @deprecated use `Detail$inboundSchema` instead. */ Detail$.inboundSchema = exports.Detail$inboundSchema;
    /** @deprecated use `Detail$outboundSchema` instead. */ Detail$.outboundSchema = exports.Detail$outboundSchema;
})(Detail$ || (exports.Detail$ = Detail$ = {}));
/** @internal */ exports.HTTPValidationError$inboundSchema = z.object({
    detail: z.union([
        z.array(shared.ValidationError$inboundSchema),
        z.string()
    ]).optional()
}).transform((v)=>{
    return new HTTPValidationError(v);
});
/** @internal */ exports.HTTPValidationError$outboundSchema = z.instanceof(HTTPValidationError).transform((v)=>v.data$).pipe(z.object({
    detail: z.union([
        z.array(shared.ValidationError$outboundSchema),
        z.string()
    ]).optional()
}));
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */ var HTTPValidationError$;
(function(HTTPValidationError$) {
    /** @deprecated use `HTTPValidationError$inboundSchema` instead. */ HTTPValidationError$.inboundSchema = exports.HTTPValidationError$inboundSchema;
    /** @deprecated use `HTTPValidationError$outboundSchema` instead. */ HTTPValidationError$.outboundSchema = exports.HTTPValidationError$outboundSchema;
})(HTTPValidationError$ || (exports.HTTPValidationError$ = HTTPValidationError$ = {})); //# sourceMappingURL=httpvalidationerror.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/models/errors/servererror.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServerError$ = exports.ServerError$outboundSchema = exports.ServerError$inboundSchema = exports.ServerError = void 0;
const z = __importStar(__turbopack_require__("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)"));
class ServerError extends Error {
    constructor(err){
        const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
        super(message);
        this.data$ = err;
        if (err.detail != null) this.detail = err.detail;
        this.name = "ServerError";
    }
}
exports.ServerError = ServerError;
/** @internal */ exports.ServerError$inboundSchema = z.object({
    detail: z.string().optional()
}).transform((v)=>{
    return new ServerError(v);
});
/** @internal */ exports.ServerError$outboundSchema = z.instanceof(ServerError).transform((v)=>v.data$).pipe(z.object({
    detail: z.string().optional()
}));
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */ var ServerError$;
(function(ServerError$) {
    /** @deprecated use `ServerError$inboundSchema` instead. */ ServerError$.inboundSchema = exports.ServerError$inboundSchema;
    /** @deprecated use `ServerError$outboundSchema` instead. */ ServerError$.outboundSchema = exports.ServerError$outboundSchema;
})(ServerError$ || (exports.ServerError$ = ServerError$ = {})); //# sourceMappingURL=servererror.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/models/errors/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/errors/httpclienterrors.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/errors/httpvalidationerror.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/errors/sdkerror.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/errors/sdkvalidationerror.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/errors/servererror.js [app-rsc] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/models/operations/partition.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PartitionResponse$ = exports.PartitionResponse$outboundSchema = exports.PartitionResponse$inboundSchema = exports.PartitionRequest$ = exports.PartitionRequest$outboundSchema = exports.PartitionRequest$inboundSchema = void 0;
const z = __importStar(__turbopack_require__("[project]/node_modules/zod/lib/index.js [app-rsc] (ecmascript)"));
const primitives_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/primitives.js [app-rsc] (ecmascript)");
const shared = __importStar(__turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/shared/index.js [app-rsc] (ecmascript)"));
/** @internal */ exports.PartitionRequest$inboundSchema = z.object({
    partition_parameters: shared.PartitionParameters$inboundSchema,
    "unstructured-api-key": z.nullable(z.string()).optional()
}).transform((v)=>{
    return (0, primitives_js_1.remap)(v, {
        "partition_parameters": "partitionParameters",
        "unstructured-api-key": "unstructuredApiKey"
    });
});
/** @internal */ exports.PartitionRequest$outboundSchema = z.object({
    partitionParameters: shared.PartitionParameters$outboundSchema,
    unstructuredApiKey: z.nullable(z.string()).optional()
}).transform((v)=>{
    return (0, primitives_js_1.remap)(v, {
        partitionParameters: "partition_parameters",
        unstructuredApiKey: "unstructured-api-key"
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */ var PartitionRequest$;
(function(PartitionRequest$) {
    /** @deprecated use `PartitionRequest$inboundSchema` instead. */ PartitionRequest$.inboundSchema = exports.PartitionRequest$inboundSchema;
    /** @deprecated use `PartitionRequest$outboundSchema` instead. */ PartitionRequest$.outboundSchema = exports.PartitionRequest$outboundSchema;
})(PartitionRequest$ || (exports.PartitionRequest$ = PartitionRequest$ = {}));
/** @internal */ exports.PartitionResponse$inboundSchema = z.object({
    ContentType: z.string(),
    Elements: z.array(z.record(z.any())).optional(),
    StatusCode: z.number().int(),
    RawResponse: z.instanceof(Response)
}).transform((v)=>{
    return (0, primitives_js_1.remap)(v, {
        "ContentType": "contentType",
        "Elements": "elements",
        "StatusCode": "statusCode",
        "RawResponse": "rawResponse"
    });
});
/** @internal */ exports.PartitionResponse$outboundSchema = z.object({
    contentType: z.string(),
    elements: z.array(z.record(z.any())).optional(),
    statusCode: z.number().int(),
    rawResponse: z.instanceof(Response).transform(()=>{
        throw new Error("Response cannot be serialized");
    })
}).transform((v)=>{
    return (0, primitives_js_1.remap)(v, {
        contentType: "ContentType",
        elements: "Elements",
        statusCode: "StatusCode",
        rawResponse: "RawResponse"
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */ var PartitionResponse$;
(function(PartitionResponse$) {
    /** @deprecated use `PartitionResponse$inboundSchema` instead. */ PartitionResponse$.inboundSchema = exports.PartitionResponse$inboundSchema;
    /** @deprecated use `PartitionResponse$outboundSchema` instead. */ PartitionResponse$.outboundSchema = exports.PartitionResponse$outboundSchema;
})(PartitionResponse$ || (exports.PartitionResponse$ = PartitionResponse$ = {})); //# sourceMappingURL=partition.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/models/operations/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/operations/partition.js [app-rsc] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/types/streams.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isReadableStream = void 0;
function isReadableStream(val) {
    if (typeof val !== "object" || val === null) {
        return false;
    }
    // Check for the presence of methods specific to ReadableStream
    const stream = val;
    // ReadableStream has methods like getReader, cancel, and tee
    return typeof stream.getReader === "function" && typeof stream.cancel === "function" && typeof stream.tee === "function";
}
exports.isReadableStream = isReadableStream; //# sourceMappingURL=streams.js.map
}}),
"[project]/node_modules/unstructured-client/funcs/generalPartition.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generalPartition = void 0;
const encodings_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/encodings.js [app-rsc] (ecmascript)");
const files_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/files.js [app-rsc] (ecmascript)");
const M = __importStar(__turbopack_require__("[project]/node_modules/unstructured-client/lib/matchers.js [app-rsc] (ecmascript)"));
const schemas_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/schemas.js [app-rsc] (ecmascript)");
const security_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/security.js [app-rsc] (ecmascript)");
const url_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/url.js [app-rsc] (ecmascript)");
const errors = __importStar(__turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/errors/index.js [app-rsc] (ecmascript)"));
const operations = __importStar(__turbopack_require__("[project]/node_modules/unstructured-client/sdk/models/operations/index.js [app-rsc] (ecmascript)"));
const blobs_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/sdk/types/blobs.js [app-rsc] (ecmascript)");
const streams_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/sdk/types/streams.js [app-rsc] (ecmascript)");
/**
 * Summary
 *
 * @remarks
 * Description
 */ async function generalPartition(client, request, options) {
    var _a;
    const parsed = (0, schemas_js_1.safeParse)(request, (value)=>operations.PartitionRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
        return parsed;
    }
    const payload = parsed.value;
    const body = new FormData();
    if ((0, blobs_js_1.isBlobLike)(payload.partition_parameters.files)) {
        body.append("files", payload.partition_parameters.files);
    } else if ((0, streams_js_1.isReadableStream)(payload.partition_parameters.files.content)) {
        const buffer = await (0, files_js_1.readableStreamToArrayBuffer)(payload.partition_parameters.files.content);
        const blob = new Blob([
            buffer
        ], {
            type: "application/octet-stream"
        });
        body.append("files", blob);
    } else {
        body.append("files", new Blob([
            payload.partition_parameters.files.content
        ], {
            type: "application/octet-stream"
        }), payload.partition_parameters.files.fileName);
    }
    if (payload.partition_parameters.chunking_strategy !== undefined) {
        body.append("chunking_strategy", String(payload.partition_parameters.chunking_strategy));
    }
    if (payload.partition_parameters.combine_under_n_chars !== undefined) {
        body.append("combine_under_n_chars", String(payload.partition_parameters.combine_under_n_chars));
    }
    if (payload.partition_parameters.content_type !== undefined) {
        body.append("content_type", String(payload.partition_parameters.content_type));
    }
    if (payload.partition_parameters.coordinates !== undefined) {
        body.append("coordinates", String(payload.partition_parameters.coordinates));
    }
    if (payload.partition_parameters.encoding !== undefined) {
        body.append("encoding", String(payload.partition_parameters.encoding));
    }
    if (payload.partition_parameters.extract_image_block_types !== undefined) {
        body.append("extract_image_block_types", String(payload.partition_parameters.extract_image_block_types));
    }
    if (payload.partition_parameters.gz_uncompressed_content_type !== undefined) {
        body.append("gz_uncompressed_content_type", String(payload.partition_parameters.gz_uncompressed_content_type));
    }
    if (payload.partition_parameters.hi_res_model_name !== undefined) {
        body.append("hi_res_model_name", String(payload.partition_parameters.hi_res_model_name));
    }
    if (payload.partition_parameters.include_orig_elements !== undefined) {
        body.append("include_orig_elements", String(payload.partition_parameters.include_orig_elements));
    }
    if (payload.partition_parameters.include_page_breaks !== undefined) {
        body.append("include_page_breaks", String(payload.partition_parameters.include_page_breaks));
    }
    if (payload.partition_parameters.include_slide_notes !== undefined) {
        body.append("include_slide_notes", String(payload.partition_parameters.include_slide_notes));
    }
    if (payload.partition_parameters.languages !== undefined) {
        body.append("languages", String(payload.partition_parameters.languages));
    }
    if (payload.partition_parameters.max_characters !== undefined) {
        body.append("max_characters", String(payload.partition_parameters.max_characters));
    }
    if (payload.partition_parameters.multipage_sections !== undefined) {
        body.append("multipage_sections", String(payload.partition_parameters.multipage_sections));
    }
    if (payload.partition_parameters.new_after_n_chars !== undefined) {
        body.append("new_after_n_chars", String(payload.partition_parameters.new_after_n_chars));
    }
    if (payload.partition_parameters.ocr_languages !== undefined) {
        body.append("ocr_languages", String(payload.partition_parameters.ocr_languages));
    }
    if (payload.partition_parameters.output_format !== undefined) {
        body.append("output_format", payload.partition_parameters.output_format);
    }
    if (payload.partition_parameters.overlap !== undefined) {
        body.append("overlap", String(payload.partition_parameters.overlap));
    }
    if (payload.partition_parameters.overlap_all !== undefined) {
        body.append("overlap_all", String(payload.partition_parameters.overlap_all));
    }
    if (payload.partition_parameters.pdf_infer_table_structure !== undefined) {
        body.append("pdf_infer_table_structure", String(payload.partition_parameters.pdf_infer_table_structure));
    }
    if (payload.partition_parameters.similarity_threshold !== undefined) {
        body.append("similarity_threshold", String(payload.partition_parameters.similarity_threshold));
    }
    if (payload.partition_parameters.skip_infer_table_types !== undefined) {
        body.append("skip_infer_table_types", String(payload.partition_parameters.skip_infer_table_types));
    }
    if (payload.partition_parameters.split_pdf_allow_failed !== undefined) {
        body.append("split_pdf_allow_failed", String(payload.partition_parameters.split_pdf_allow_failed));
    }
    if (payload.partition_parameters.split_pdf_concurrency_level !== undefined) {
        body.append("split_pdf_concurrency_level", String(payload.partition_parameters.split_pdf_concurrency_level));
    }
    if (payload.partition_parameters.split_pdf_page !== undefined) {
        body.append("split_pdf_page", String(payload.partition_parameters.split_pdf_page));
    }
    if (payload.partition_parameters.split_pdf_page_range !== undefined) {
        body.append("split_pdf_page_range", String(payload.partition_parameters.split_pdf_page_range));
    }
    if (payload.partition_parameters.starting_page_number !== undefined) {
        body.append("starting_page_number", String(payload.partition_parameters.starting_page_number));
    }
    if (payload.partition_parameters.strategy !== undefined) {
        body.append("strategy", payload.partition_parameters.strategy);
    }
    if (payload.partition_parameters.unique_element_ids !== undefined) {
        body.append("unique_element_ids", String(payload.partition_parameters.unique_element_ids));
    }
    if (payload.partition_parameters.xml_keep_tags !== undefined) {
        body.append("xml_keep_tags", String(payload.partition_parameters.xml_keep_tags));
    }
    const path = (0, url_js_1.pathToFunc)("/general/v0/general")();
    const headers = new Headers({
        Accept: "application/json",
        "unstructured-api-key": (0, encodings_js_1.encodeSimple)("unstructured-api-key", payload["unstructured-api-key"], {
            explode: false,
            charEncoding: "none"
        })
    });
    const securityInput = await (0, security_js_1.extractSecurity)(client._options.security);
    const context = {
        operationID: "partition",
        oAuth2Scopes: [],
        securitySource: client._options.security
    };
    const requestSecurity = (0, security_js_1.resolveGlobalSecurity)(securityInput);
    const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "POST",
        path: path,
        headers: headers,
        body: body,
        timeoutMs: (options === null || options === void 0 ? void 0 : options.timeoutMs) || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
        return requestRes;
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
        context,
        errorCodes: [
            "422",
            "4XX",
            "5XX"
        ],
        retryConfig: (options === null || options === void 0 ? void 0 : options.retries) || client._options.retryConfig || {
            strategy: "backoff",
            backoff: {
                initialInterval: 3000,
                maxInterval: 720000,
                exponent: 1.88,
                maxElapsedTime: 1800000
            },
            retryConnectionErrors: true
        },
        retryCodes: (options === null || options === void 0 ? void 0 : options.retryCodes) || [
            "502",
            "503",
            "504"
        ]
    });
    if (!doResult.ok) {
        return doResult;
    }
    const response = doResult.value;
    const responseFields = {
        ContentType: (_a = response.headers.get("content-type")) !== null && _a !== void 0 ? _a : "application/octet-stream",
        StatusCode: response.status,
        RawResponse: response,
        Headers: {}
    };
    const [result] = await M.match(M.json(200, operations.PartitionResponse$inboundSchema, {
        key: "Elements"
    }), M.jsonErr(422, errors.HTTPValidationError$inboundSchema), M.fail("4XX"), M.jsonErr("5XX", errors.ServerError$inboundSchema))(response, {
        extraFields: responseFields
    });
    if (!result.ok) {
        return result;
    }
    return result;
}
exports.generalPartition = generalPartition; //# sourceMappingURL=generalPartition.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/general.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.General = void 0;
const generalPartition_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/funcs/generalPartition.js [app-rsc] (ecmascript)");
const sdks_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/sdks.js [app-rsc] (ecmascript)");
const fp_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/sdk/types/fp.js [app-rsc] (ecmascript)");
class General extends sdks_js_1.ClientSDK {
    /**
     * Summary
     *
     * @remarks
     * Description
     */ async partition(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, generalPartition_js_1.generalPartition)(this, request, options));
    }
}
exports.General = General; //# sourceMappingURL=general.js.map
}}),
"[project]/node_modules/unstructured-client/sdk/sdk.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UnstructuredClient = void 0;
const sdks_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/lib/sdks.js [app-rsc] (ecmascript)");
const general_js_1 = __turbopack_require__("[project]/node_modules/unstructured-client/sdk/general.js [app-rsc] (ecmascript)");
class UnstructuredClient extends sdks_js_1.ClientSDK {
    get general() {
        var _a;
        return (_a = this._general) !== null && _a !== void 0 ? _a : this._general = new general_js_1.General(this._options);
    }
}
exports.UnstructuredClient = UnstructuredClient; //# sourceMappingURL=sdk.js.map
}}),
"[project]/node_modules/unstructured-client/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.files = void 0;
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/lib/config.js [app-rsc] (ecmascript)"), exports);
exports.files = __importStar(__turbopack_require__("[project]/node_modules/unstructured-client/lib/files.js [app-rsc] (ecmascript)"));
__exportStar(__turbopack_require__("[project]/node_modules/unstructured-client/sdk/sdk.js [app-rsc] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),

};

//# sourceMappingURL=node_modules_unstructured-client_7474ee._.js.map